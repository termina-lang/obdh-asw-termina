import{modules.tm_ccsds_pus_format, modules.serialize, resources.tmchannel.tmchannel_queue, resources.uart}


const MAX : usize = 256 : usize;
const FIFO_SIZE : usize = 16 : usize;

interface TMChannel {

    procedure get_next_tm_count(&priv self, count : &mut u16);

    procedure send_tm<const MAX: usize>(&priv self, tm_descriptor: &TMDescriptorT, result : &mut Result);

    procedure release_tx<const FIFO_SIZE : usize>(&priv self, result : &mut Result);

};



resource class CTMChannel provides TMChannel {

    
    tm_count : u16;
    tm_queue : access TMQueueIO;
    tm_descriptor_pool: access Allocator<TMDescriptorT>;
    uart : access UARTDriver;

    tx_full : bool; //This is a flag to indicate that the TX queue is full and no more TMs can be inserted.
    

   procedure get_next_tm_count(&priv self, count : &mut u16) {

        *count = self->tm_count;
        self->tm_count = (self->tm_count + 1 : u16) & 0x3FFF : u16;

        return;
   }


   procedure send_tm<const MAX: usize>(&priv self, tm_descriptor: &TMDescriptorT, result : &mut Result){

        *result = Result::Ok;

        if self->tx_full == false {

            var sent_bytes : u16 = 0;
            var is_txfifo_full : bool = false;
            
            for i : usize in 0 .. MAX while ((is_txfifo_full == false) && (sent_bytes < (*tm_descriptor).tm_num_bytes)){

                self->uart.putchar((*tm_descriptor).tm_bytes[i], &mut is_txfifo_full);
                sent_bytes = sent_bytes + 1;

            }

            if (sent_bytes < (*tm_descriptor).tm_num_bytes) {

                //Copy remaining bytes to inner queue
                // if inner queue is full, return error

                self->tx_full = true;

                var tm_descriptor2 : TMDescriptorT =  {
                    tm_bytes = [0 : u8; 256],
                    tm_num_bytes = 0 : u16
                }: TMDescriptorT;

                tm_descriptor2.tm_num_bytes = (*tm_descriptor).tm_num_bytes - sent_bytes;
                tm_descriptor2.tm_bytes[0 : usize .. (tm_descriptor2.tm_num_bytes - 1 : u16) as usize] = (*tm_descriptor).tm_bytes[sent_bytes as usize .. ((*tm_descriptor).tm_num_bytes - 1 : u16) as usize];
                self->tm_queue.enqueue_back(tm_descriptor2, &mut result);

                  
                }
            
                
        } else {
        
            //Copy all the bytes to inner queue
            // if inner queue is full, return error

            self->tm_queue.enqueue_back(descriptor, &mut result);

        }       
    

    return;

   }

   
   procedure release_tx<const FIFO_SIZE : usize>(&priv self, result : &mut Result){

    if (self->tx_full == false){

        // do nothing

    } else {
        
        var sent_bytes : u16 = 0;
        var tm_descriptor : TMDescriptorT = {
            tm_bytes = [0 : u8; 256],
            tm_num_bytes = 0 : u16
        }: TMDescriptorT;

        self->tm_queue.dequeue_front(&mut tm_descriptor, &mut result);

        for i : usize in 0 .. FIFO_SIZE while ((is_txfifo_full == false) && (is_innerqueue_empty == false)){

            self->uart.putchar((*tm_descriptor).tm_bytes[i], &mut is_txfifo_full);
            sent_bytes = sent_bytes + 1;
            self->tm_queue.is_empty(&mut is_innerqueue_empty);

        }

        if (sent_bytes < tm_descriptor.tm_num_bytes) {
        
           // I can't call insert_tm, the remaining bytes should be inserted in the head of the queue not in the tail 
           //I can implement a dequeue
            var tm_descriptor2 : TMDescriptorT =  {
                    tm_bytes = [0 : u8; 256],
                    tm_num_bytes = 0 : u16
                }: TMDescriptorT;

            tm_descriptor2.tm_num_bytes = (*tm_descriptor).tm_num_bytes - sent_bytes;
            tm_descriptor2.tm_bytes[0 : usize .. (tm_descriptor2.tm_num_bytes - 1 : u16) as usize] = (*tm_descriptor).tm_bytes[sent_bytes as usize .. ((*tm_descriptor).tm_num_bytes - 1 : u16) as usize];
            self->tm_queue.enqueue_front(tm_descriptor2, &mut result);

              
            self->tx_full = true;

        } else {

            self->tx_full = false;

        }
    }
    
    return;

   }

        

   
   };