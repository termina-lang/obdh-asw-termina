import{modules.tm_ccsds_pus_format, modules.serialize}

interface TMChannel {

    procedure get_next_tm_count(&priv self, count : &mut u16);

    procedure insert_tm(&priv self, tm_descriptor: dyn TMDescriptorT);

};

const TM_QUEUE_MAX_NOE : u8 = 20 : u8;

resource class CTMChannel provides TMChannel {

    tm_descriptor_queue : TMDescriptorQueue;
    tm_count : u16;
    tm_list_count : u8;
    a_tm_descriptor_pool : access Allocator<TMDescriptorT>;

   procedure get_next_tm_count(&priv self, count : &mut u16) {

        *count = self->tm_count;
        self->tm_count = (self->tm_count + 1 : u16) & 0x3FFF : u16;

        return;
   }

   procedure init_system_tm_queue(&priv self){

        self->tm_descriptor_queue.head_index = 0 : u8;
    	self->tm_descriptor_queue.queued_tms = 0 : u8;
    }

    viewer tm_queue_is_full(&self) -> bool {

        var is_full : u8 = (self->tm_descriptor_queue.queued_tms == TM_QUEUE_MAX_NOE);
	    return is_full;
    }

    viewer tm_queue_is_empty(&self) -> bool {

	    var is_empty : u8 = (self->tm_descriptor_queue.queued_tms) == 0 : u8;
	    return is_empty;
    }   

    procedure insert_tm (&priv self, tm_descriptor: &TMDescriptorT, result : &mut Result) {

        var is_full : bool = self->tm_queue_is_full();

        if (false == is_full) {
            
            next_tail_index = (self->tm_descriptor_queue.head_index + self->tm_descriptor_queue.queued_tms) % TM_QUEUE_MAX_NOE;

            self->tm_descriptor_queue.tm_descriptors[next_tail_index as usize] = tm_descriptor;

            self->tm_descriptor_queue.queued_tms = self->tm_descriptor_queue.queued_tms + 1 : u8;

            *result = Result::Ok;

            self->a_tm_descriptor_pool.free(tm_descriptor);

        } else { 
            *result = Result::Error;
        }

        return;
    }

    procedure send_tm_list(&priv self, tm_descriptor: dyn TMDescriptorT) {

        var frame_header : [u8;6] = [0 : u8;6];

        frame_header[0 : usize] = 0xBE : u8;
        frame_header[1 : usize] = 0xBA : u8;
        frame_header[2 : usize] = 0xBE : u8;
        frame_header[3 : usize] = 0xEF : u8;

    
        serialize_uint16(tm_descriptor.tm_num_bytes, &mut frame_header[4 : usize .. 6 : usize]);

        
        //HARDWARE DEPENDENT. Pending determination of the hardware where the code is to be tested.
        

        

        return;

    }
   
   };