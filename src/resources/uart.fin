
//#[packed]
struct UARTRegs {
    data : u32;
    status : u32;
    control :  u32;
    scaler : u32;
};

interface UARTDriver {

    procedure riscv_uart_tf_is_empty(&mut self, res : &mut bool);

    procedure riscv_uart_enable_TX(&mut self);

    procedure riscv_uart_enable_RX(&mut self);

    procedure riscv_uart_enable_RI(&mut self);
    
    procedure riscv_putchar(&mut self, c : u8, status : &mut Status<i32>);

    procedure riscv_getchar(&mut self, uart_data : &mut Option<u8>);

};

constexpr uart_timeout : u32 = 0xAAAAA : u32;

resource class CRISCVUARTDriver provides UARTDriver {

    uart_regs: loc UARTRegs;

    viewer riscv_uart_tf_is_full(&self) -> bool {
        let riscv_uart_tf : u32 = 0x00000200 : u32;
        return ((self->uart_regs.status & riscv_uart_tf) != 0);
    }

    procedure riscv_uart_tf_is_empty(&mut self, res : &mut bool) {
        let riscv_uart_te : u32 = 0x00000004 : u32;
        *res = ((self->uart_regs.status & riscv_uart_te) != 0);
        return;
    }


    procedure riscv_uart_enable_TX(&mut self) {
        let riscv_uart_txe : u32 = 0x00000002 : u32;
        self->uart_regs.control = self->uart_regs.control | riscv_uart_txe;
        return;
    }

    procedure riscv_uart_enable_RX(&mut self) {
        let riscv_uart_rxe : u32 = 0x00000001 : u32;
        self->uart_regs.control = self->uart_regs.control | riscv_uart_rxe;
        return;
    }

    procedure riscv_uart_enable_RI(&mut self) {
        let riscv_uart_ri : u32 = 0x00000004 : u32;
        self->uart_regs.control = self->uart_regs.control | riscv_uart_ri;
        return;
    }

    
    procedure riscv_putchar(&mut self, c : u8, status : &mut Status<i32>) {
        
        var write_timeout : u32 = 0 : u32;

        *status = Failure(-1);

        for i : u32 in 0 : u32 .. uart_timeout while self->riscv_uart_tf_is_full() {
            
            write_timeout = write_timeout + 1 : u32;

        }

        if (write_timeout < uart_timeout){
            self->uart_regs.data = c as u32;
            *status = Success;
        }

        return;
    
    }


  procedure riscv_getchar(&mut self, uart_data : &mut Option<u8>) {
        
        let riscv_uart_dr : u32 = 0x00000001;

        if ((self->uart_regs.status & riscv_uart_dr) != 0) {
            *uart_data = Some(self->uart_regs.data as u8);
        }
        else{
            *uart_data = None;
        }

        return;

    }


};

