import service_libraries.queue_u8;

//#[packed]
struct UARTRegs {
    data : u32;
    status : u32;
    control :  u32;
    scaler : u32;
};


enum CharDevResult {
    Success,
    TXFIFOFull
};

const max_send_size : usize = 256;

interface CharDevSend {
    procedure send(&mut self,
                   output_bytes : & [u8; max_send_size], 
                   nbytes : usize, 
                   result : &mut CharDevResult);
};

interface CharDevInit {
    procedure initialize(&mut self);
};

interface CharDevRelayIrq {
     procedure release_tx(&mut self);
};


resource class UARTDriver provides 
        CharDevSend, CharDevInit, CharDevRelayIrq {

    // UART registers
    registers: loc UARTRegs;

    //Flag to indicate that there are bytes enqueued that must be sent
    rem_bytes : bool;

    // TX queue
    uart_queue : QueueU8;

    viewer tf_is_full(&self) -> bool {
        let riscv_uart_tf : u32 = 0x00000200 : u32;
        return ((self->registers.status & riscv_uart_tf) != 0 : u32);
    }

    viewer tf_is_empty(&self) -> bool {
        let riscv_uart_te : u32 = 0x00000004 : u32;
        return ((self->registers.status & riscv_uart_te) != 0 : u32);
    }


    method enable_TX(&priv self) {
        let riscv_uart_txe : u32 = 0x00000002 : u32;
        self->registers.control = self->registers.control | riscv_uart_txe;
        return;
        
    }

    method enable_RX(&priv self) {
        let riscv_uart_rxe : u32 = 0x00000001 : u32;
        self->registers.control = self->registers.control | riscv_uart_rxe;
        return;
    }

    method enable_RI(&priv self) {
        let riscv_uart_ri : u32 = 0x00000004 : u32;
        self->registers.control = self->registers.control | riscv_uart_ri;
        return;
    }

    method enable_TI(&priv self) {
        let riscv_uart_ti : u32 = 0x00000008 : u32;
        self->registers.control = self->registers.control | riscv_uart_ti;
        return;
    }

    method disable_TF(&priv self) {
        let riscv_uart_tf : u32 = 0xFFFFFCFF : u32;
        self->registers.control = self->registers.control & riscv_uart_tf;
        return;
    }

    method disable_RF(&priv self) {
        let riscv_uart_rf : u32 = 0xFFFFFBFF : u32;
        self->registers.control = self->registers.control & riscv_uart_rf;
        return;
    }


    procedure release_tx(&mut self) {

        if(self->rem_bytes){

            var num_elements : usize = 0;

            get_num_enqueued_elems (&(self->uart_queue),&mut num_elements);

            var sent_bytes : usize = 0;
            var extracted_elem : Option<u8> = None;

    

            for i : usize in 0 : usize .. 4 while (sent_bytes < num_elements) {

                dequeue(&mut(self->uart_queue), &mut extracted_elem);

                match extracted_elem {
                    case Some(elem) => {
                        self->registers.data = elem as u32;
                        sent_bytes = sent_bytes + 1;
                    }
                    case None => {
                        //queue is empty
                    }
                }

            }

            

            if (sent_bytes < num_elements) {
                
                self->rem_bytes = true;

            } else {

                self->rem_bytes = false;
            }
            

        }

        return;
    }

    procedure send(&mut self, output_bytes : & [u8; max_send_size], 
                   nbytes : usize, 
                   result : &mut CharDevResult) {

        *result = CharDevResult::Success;

        if (self->rem_bytes){

            var num_elements : usize = 0;
            get_num_enqueued_elems(&(self->uart_queue), &mut num_elements);

            if ((queue_max_noe-num_elements) >= nbytes) {

                var inner_queue_result : QueueResult = QueueResult::Success;
                var queued_bytes : usize = 0;
                var error : bool = false;

                for i : usize in 0 : usize .. max_send_size while (queued_bytes < nbytes && error == false) {

                    inner_queue_result = enqueue(&mut(self->uart_queue), (*output_bytes)[i]);

                    if (inner_queue_result is QueueResult::QueueFull) {
                        
                        error = true;
                        *result = CharDevResult::TXFIFOFull;
                    
                    } else {
                        queued_bytes = queued_bytes + 1;
                    }
                    
                    
                }


            } else {
                
                *result = CharDevResult::TXFIFOFull;
            }



        } else {

            var sent_bytes : usize = 0;

            if (self->tf_is_empty()) {

                for i : usize in 0 : usize .. 4 while (sent_bytes < nbytes) {

                    self->registers.data = output_bytes[i] as u32;
                    sent_bytes = sent_bytes + 1;
                    
                }

            }

            if (sent_bytes < nbytes) {

                self->rem_bytes = true;

                var left_bytes : usize = nbytes - sent_bytes;
                var num_elements : usize = 0;

                get_num_enqueued_elems(&(self-> uart_queue), &mut num_elements);

                if ((queue_max_noe-num_elements) >= left_bytes) {

                    var inner_queue_result : QueueResult = QueueResult::Success;
                    var error : bool = false;

                    for i : usize in 0 .. max_send_size while (i < left_bytes && error == false){

                        inner_queue_result = enqueue(&mut(self->uart_queue), (*output_bytes)[i+sent_bytes]);

                        if (inner_queue_result is QueueResult::QueueFull) {
                        
                        error = true;
                        *result = CharDevResult::TXFIFOFull;
                    
                        } else {
                            
                        }
                        
                    }

                } else {
                    
                    *result = CharDevResult::TXFIFOFull;
                }

            }

        }

        return;
    }


    procedure initialize(&mut self) {

        self->enable_RX();
        self->enable_TX();
        self->enable_RI();
        self->enable_TI();
        self->disable_TF();
        self->disable_RF();

        return;

    }

};

