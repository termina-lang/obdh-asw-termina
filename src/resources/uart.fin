
//#[packed]
struct UARTRegs {
    data : u32;
    status : u32;
    control :  u32;
    scaler : u32;
};

interface UARTDriver {

    procedure riscv_uart_tf_is_empty(&priv self, res : &mut bool);

    procedure riscv_uart_enable_TX(&priv self);

    procedure riscv_uart_enable_RX(&priv self);

    procedure riscv_uart_enable_RI(&priv self);
    
    procedure riscv_putchar(&priv self, c : u8, result : &mut Result);

    procedure riscv_getchar(&priv self, uart_data : &mut u8, result : &mut Result);

};


resource class CRISCVUARTDriver provides UARTDriver {

    uart_regs: loc UARTRegs;

    viewer riscv_uart_tf_is_full(&self) -> bool {
        let riscv_uart_tf : u32 = 0x00000200 : u32;
        return ((self->uart_regs.status & riscv_uart_tf) != 0 : u32);
    }

    procedure riscv_uart_tf_is_empty(&priv self, res : &mut bool) {
        let riscv_uart_te : u32 = 0x00000004 : u32;
        *res = ((self->uart_regs.status & riscv_uart_te) != 0 : u32);
        return;
    }


    procedure riscv_uart_enable_TX(&priv self) {
        let riscv_uart_txe : u32 = 0x00000002 : u32;
        self->uart_regs.control = self->uart_regs.control | riscv_uart_txe;
        return;
    }

    procedure riscv_uart_enable_RX(&priv self) {
        let riscv_uart_rxe : u32 = 0x00000001 : u32;
        self->uart_regs.control = self->uart_regs.control | riscv_uart_rxe;
        return;
    }

    procedure riscv_uart_enable_RI(&priv self) {
        let riscv_uart_ri : u32 = 0x00000004 : u32;
        self->uart_regs.control = self->uart_regs.control | riscv_uart_ri;
        return;
    }

    
    procedure riscv_putchar(&priv self, c : u8, result : &mut Result) {
        
        var write_timeout : u32 = 0 : u32;
        let timeout : u32 = 0xAAAAA : u32;

        *result = Result::Error;

        for i : u32 in 0 : u32 .. timeout while self->riscv_uart_tf_is_full() {
            
            write_timeout = write_timeout + 1 : u32;

        }

        if (write_timeout < timeout){
            self->uart_regs.data = c as u32;
            *result = Result::Ok;
        }

        return;
    
    }


  procedure riscv_getchar(&priv self, uart_data : &mut u8, result : &mut Result) {
        
        let riscv_uart_dr : u32 = 0x00000001 : u32;

        if ((self->uart_regs.status & riscv_uart_dr) != 0 : u32) {
            *uart_data = self->uart_regs.data as u8;
            *result = Result::Ok;
        }
        else{
            *result = Result::Error;
        }

        return;

    }


};

