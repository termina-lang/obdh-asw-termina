/*
PUS SERVICE 19 : EVENT-ACTION
*/

import service_libraries.pus_services.pus_service5.pus_service5;
import service_libraries.pus_services.pus_service1.pus_service1;
import service_libraries.serialize;
import service_libraries.tc_ccsds_pus_format;
import service_libraries.tm_ccsds_pus_format;
import service_libraries.event_list;
const event_action_max_bytes : usize = 242;


const max_event_action_definitions : usize = 16;
const event_action_queue_dimension : usize = 8;


struct EventActionConfig {
    enabled: bool;
    event_ID: u16;
};



interface PUSS19Iface {

     procedure exec19_1TC (&mut self, tc_handler: &mut TCHandlerT, result: &mut Result);
    procedure exec19_2TC (&mut self, tc_handler: &mut TCHandlerT, result: &mut Result);
    procedure exec19_4TC (&mut self, tc_handler: &mut TCHandlerT, result: &mut Result);
    procedure exec19_5TC (&mut self, tc_handler: &mut TCHandlerT, result: &mut Result);
    procedure manage_event_actions(&mut self, event_list: &mut EventList);
    procedure get_pending_action_number(&mut self, paction_num : &mut[usize;4]);
    procedure extract_action (&mut self, index : usize, action_packet : &mut TCDescriptorT);
    
};

resource class PUSService19 provides PUSS19Iface {

    event_action_config : [EventActionConfig; max_event_action_definitions];
    event_action_packets : [TCHandlerT; max_event_action_definitions];
   
    pending_action_queue_1I : [TCDescriptorT; event_action_queue_dimension];
    pending_action_queue_2LS : [TCDescriptorT; event_action_queue_dimension];
    pending_action_queue_3MS : [TCDescriptorT; event_action_queue_dimension];
    pending_action_queue_4HS : [TCDescriptorT; event_action_queue_dimension];
    
    pending_action_number : [usize; 4];
    pending_action_head : [usize; 4];
   
    pus_service_5 : access PUSS5Iface;

    tm_channel: access TMChannelIface;   
    a_tm_handler_pool : access Allocator<TMHandlerT>;
    tm_counter : access TMCounterIface;


//I obviosuly know the following functions can't be viewers
    viewer disable_event_action (&self, evID: u16, ev_action_ID : u16) -> Result {

        var result : Result = Result::Error;
        if(evID == self->event_action_config[ev_action_ID].event_ID){

            self->event_action_config[ev_action_ID].enabled = false;
            result = Result::Ok;

        } 

        return result;
    }


    viewer enable_event_action (&self, evID: u16, ev_action_ID : u16) -> Result {

        var result : Result = Result::Error;
        if(evID == self->event_action_config[ev_action_ID].event_ID){

            self->event_action_config[ev_action_ID].enabled = true;
            result = Result::Ok;

        } 

        return result;
    }

    viewer delete_event_action (&self, evID: u16, ev_action_ID : u16) -> Result {

        var result : Result = Result::Error;
        if(evID == self->event_action_config[ev_action_ID].event_ID){

            self->event_action_config[ev_action_ID].event_ID = 0;
            self->event_action_config[ev_action_ID].enabled = false;
            result = Result::Ok;

        } 

        return result;
    }


    viewer get_event_action_config (&self, evID: u16, index: &mut usize, enabled: &mut bool) -> bool {

        var found: bool = false;

        for i : usize in 0 .. max_event_action_definitions while found == false {

            if (self->event_action_config[i].event_ID == evID) {

                    *index = i;
                    *enabled = self->event_action_config[i].enabled;
                    found = true;
            }
        }
        return found;
    }

    viewer get_free_event_action_index (&self, index: &mut usize)->bool {

        var found: bool = false;

        for i : usize in 0 .. max_event_action_definitions while found == false {

            if (self->event_action_config[i].event_ID == 0) {

                *index = i;
                found = true;
            }
        }
        return found;
    }


    viewer is_ev_action_defined (&self, evID: u16, ev_action_ID : &mut u16, enabled : &mut u16) -> bool {

        var found: bool = false;

        for i : usize in 0 .. max_event_action_definitions while found == false {

            if (self->event_action_config[i].event_ID == evID) {

                *ev_action_ID = i;
                *enabled = self->event_action_config[i].enabled;
                found = true;
            }
        }
        return found;

    }


    //TC[19,1] allows the addition of event-action definitions
    procedure exec19_1TC (&mut self, tc_handler: &mut TCHandlerT , result: &mut Result){

        var tm_handler : Option<box TMHandlerT> = None;
        self->a_tm_handler_pool.alloc(&mut tm_handler);

        match tm_handler {

            case Some(b_tm_handler) => {

                var tm_count : u16 = 0 : u16;
                self->tm_counter.get_next_tm_count(&mut tm_count);

                var N : u8 = 0;
                var EvID : u16 = 0;

                *result = tc_handler_get_u8_appdata_field(tc_handler, &mut N);
                *result = tc_handler_get_u16_appdata_field(tc_handler, &mut EvID);

                if (*result is Result::Error){

                    build_tm_1_4_short_pack_length(&mut b_tm_handler, tm_count, &(*tc_handler), result);
                } 
                else {

                    if (N != 1) {

                        build_tm_1_4_num_of_instr_not_valid(&mut b_tm_handler, tm_count, &(*tc_handler), N, result);
                    }
                    else {

                        if (is_Ev_ID_valid(EvID)) {

                            var event_action_ID : u16 = 0;
                            var is_enabled : bool = false;
                            var is_defined : bool = false;

                            is_defined = self->is_ev_action_defined(EvID, &mut event_action_ID, &mut is_enabled);

                            if (is_defined){

                                if (is_enabled){

                                    build_tm_1_4_event_action_enabled(&mut b_tm_handler, tm_count, &(*tc_handler), EvID, result);
                                }

                            } else {

                                if(self->get_free_event_action_index(&mut ev_action_ID)){

                                    var action_tc_packet : TCDescriptorT = {
                                        tc_bytes = [0; event_action_max_bytes],
                                        tc_num_bytes = 0
                                    };
                                    action_tc_packet.tc_num_bytes = tc_handler->tc_descriptor.tc_num_bytes - 2 - tc_handler->app_data_index;
                                    
                                    for i : usize in 0 .. event_action_max_bytes while i < action_packet_length {

                                        action_tc_packet.tc_bytes[i] = tc_descriptor->tc_bytes[i + 12];

                                    }

                                   var action_tc_handler : TCHandlerT = tc_handler_init();

                                   *result = tc_handler_build_from_descriptor (&mut action_tc_handler, &action_tc_packet);
                                
                                    var tc_status : TCStatus = {
                                        acceptation_status = TCAcceptationStatus::Undefined,
                                        execution_status = TCExecutionCtrl::Undefined,
                                        error_code =  TCErrorType::Undefined
                                    };

                                    tc_status = try_tc_acceptation(&action_tc_packet); 

                                    if (tc_status.acceptation_status is TCAcceptationStatus::Accepted){

                                        build_tm_1_3(&mut b_tm_handler, tm_count, &(*tc_handler), result);
                                    
                                        self->event_action_config[index].event_ID = evID;
                                        self->event_action_config[index].enabled = false;

                                        //*result = self->disable_event_action(EvID, event_action_ID);

                                        var tm_handler2 : Option<box TMHandlerT> = None;
                                        self->a_tm_handler_pool.alloc(&mut tm_handler2);

                                        match tm_handler2 {

                                            case Some(b_tm_handler2) => {

                                                var tm_count2 : u16 = 0 : u16;
                                                self->tm_counter.get_next_tm_count(&mut tm_count2);
                                                build_tm_1_7(&mut b_tm_handler2, tm_count2, &(*tc_handler), result);
                                                self->tm_channel.send_tm(b_tm_handler2, result);
                                            }
                                            case None => {
                                                *result = Result::Error;
                                            }
                                        }

                                    } else {

                                        build_tm_1_4_ev_action_rejected (&mut b_tm_handler, tm_count, &(*tc_handler), EvID, result);
                                        
                                    }


                                }
                                else {

                                    build_tm_1_8_tc_19_1_max_event_actions(&mut b_tm_handler, tm_count, &(*tc_handler), EvID, result);
                                }

                            }
                            

                        } else {

                            build_tm_1_4_EvID_not_valid(&mut b_tm_handler, tm_count, &(*tc_handler), EvID, result);

                        }

                    }

                    self->tm_channel.send_tm(b_tm_handler, result);
                }


            }
            case None => {
                *result = Result::Error;
            }
        }

        return;
    }


//TC[19,2] allows the deletion of event-action definitions
    procedure exec19_2TC (&mut self, tc_handler: &mut TCHandlerT, result: &mut Result){

        var tm_handler : Option<box TMHandlerT> = None;
        self->a_tm_handler_pool.alloc(&mut tm_handler);

        match tm_handler {

            case Some(b_tm_handler) => {

                var tm_count : u16 = 0 : u16;
                self->tm_counter.get_next_tm_count(&mut tm_count);

                var N : u8 = 0;
                var EvID : u16 = 0;

                *result = tc_handler_get_u8_appdata_field(tc_handler, &mut N);
                *result = tc_handler_get_u16_appdata_field(tc_handler, &mut EvID);

                if (*result is Result::Error){

                    build_tm_1_4_short_pack_length(&mut b_tm_handler, tm_count, &(*tc_handler), result);
                } 
                else {

                    if (N != 1) {

                        build_tm_1_4_num_of_instr_not_valid(&mut b_tm_handler, tm_count, &(*tc_handler), N, result);
                    }
                    else {

                        if (is_Ev_ID_valid(EvID)) {

                            var event_action_ID : u16 = 0;
                            var is_enabled : bool = false;
                            var is_defined : bool = false;

                            is_defined = self->is_ev_action_defined(EvID, &mut event_action_ID, &mut is_enabled);

                            if (is_defined){

                                if (is_enabled){

                                    build_tm_1_4_event_action_enabled(&mut b_tm_handler, tm_count, &(*tc_handler), EvID, result);

                                } else {

                                    build_tm_1_3(&mut b_tm_handler, tm_count, &(*tc_handler), result);

                                    *result = self->disable_event_action(EvID, event_action_ID);

                                    var tm_handler2 : Option<box TMHandlerT> = None;
                                    self->a_tm_handler_pool.alloc(&mut tm_handler2);

                                    match tm_handler2 {

                                        case Some(b_tm_handler2) => {

                                            var tm_count2 : u16 = 0 : u16;
                                            self->tm_counter.get_next_tm_count(&mut tm_count2);
                                            build_tm_1_7(&mut b_tm_handler2, tm_count2, &(*tc_handler), result);
                                            self->tm_channel.send_tm(b_tm_handler2, result);
                                        }
                                        case None => {
                                            *result = Result::Error;
                                        }
                                    }

                                }

                            } else {

                                built_tm_1_4_ev_action_not_defined(&mut b_tm_handler, tm_count, &(*tc_handler), EvID, result);
                            }
                        } else {
                            
                            build_tm_1_4_EvID_not_valid(&mut b_tm_handler, tm_count, &(*tc_handler), EvID, result);
                        }
                    }
                }

                self->tm_channel.send_tm(b_tm_handler, result);
            }
            case None => {
                *result = Result::Error;
            }
        } 
        return;
    }


    //TC[19,4] allows enabling event-action definitions
    procedure exec19_4TC (&mut self, tc_handler: &mut TCHandlerT , result: &mut Result){

        var tm_handler : Option<box TMHandlerT> = None;
        self->a_tm_handler_pool.alloc(&mut tm_handler);

        match tm_handler {

            case Some(b_tm_handler) => {

                var tm_count : u16 = 0 : u16;
                self->tm_counter.get_next_tm_count(&mut tm_count);

                var N : u8 = 0;
                var EvID : u16 = 0;

                *result = tc_handler_get_u8_appdata_field(tc_handler, &mut N);
                *result = tc_handler_get_u16_appdata_field(tc_handler, &mut EvID);

                if (*result is Result::Error){

                    build_tm_1_4_short_pack_length(&mut b_tm_handler, tm_count, &(*tc_handler), result);
                } 
                else {

                    if (N != 1) {

                        build_tm_1_4_num_of_instr_not_valid(&mut b_tm_handler, tm_count, &(*tc_handler), N, result);
                    }
                    else {

                        if (is_Ev_ID_valid(EvID)) {

                            var event_action_ID : u16 = 0;
                            var is_enabled : bool = false;
                            var is_defined : bool = false;

                            is_defined = self->is_ev_action_defined(EvID, &mut event_action_ID, &mut is_enabled);

                            if (is_defined){

                                    build_tm_1_3(&mut b_tm_handler, tm_count, &(*tc_handler), result);

                                    *result = self->enable_event_action(EvID, event_action_ID);

                                    var tm_handler2 : Option<box TMHandlerT> = None;
                                    self->a_tm_handler_pool.alloc(&mut tm_handler2);

                                    match tm_handler2 {

                                        case Some(b_tm_handler2) => {

                                            var tm_count2 : u16 = 0 : u16;
                                            self->tm_counter.get_next_tm_count(&mut tm_count2);
                                            build_tm_1_7(&mut b_tm_handler2, tm_count2, &(*tc_handler), result);
                                            self->tm_channel.send_tm(b_tm_handler2, result);
                                        }
                                        case None => {
                                            *result = Result::Error;
                                        }
                                    }

                            } else {

                                built_tm_1_4_ev_action_not_defined(&mut b_tm_handler, tm_count, &(*tc_handler), EvID, result);
                            }
                        } else {
                            
                            build_tm_1_4_EvID_not_valid(&mut b_tm_handler, tm_count, &(*tc_handler), EvID, result);
                        }
                    }
                }
                self->tm_channel.send_tm(b_tm_handler, result);
            }
            case None => {
                *result = Result::Error;
            }
        }

        return; 
    }

    //TC[19,5] allows disabling event-action definitions
    procedure exec19_5TC (&mut self, tc_handler: &mut TCHandlerT , result: &mut Result){

        var tm_handler : Option<box TMHandlerT> = None;
        self->a_tm_handler_pool.alloc(&mut tm_handler);

        match tm_handler {

            case Some(b_tm_handler) => {

                var tm_count : u16 = 0 : u16;
                self->tm_counter.get_next_tm_count(&mut tm_count);

                var N : u8 = 0;
                var EvID : u16 = 0;

                *result = tc_handler_get_u8_appdata_field(tc_handler, &mut N);
                *result = tc_handler_get_u16_appdata_field(tc_handler, &mut EvID);

                if (*result is Result::Error){

                    build_tm_1_4_short_pack_length(&mut b_tm_handler, tm_count, &(*tc_handler), result);
                } 
                else {

                    if (N != 1) {

                        build_tm_1_4_num_of_instr_not_valid(&mut b_tm_handler, tm_count, &(*tc_handler), N, result);
                    }
                    else {

                        if (is_Ev_ID_valid(EvID)) {

                            var event_action_ID : u16 = 0;
                            var is_enabled : bool = false;
                            var is_defined : bool = false;

                            is_defined = self->is_ev_action_defined(EvID, &mut event_action_ID, &mut is_enabled);

                            if (is_defined){

                                    build_tm_1_3(&mut b_tm_handler, tm_count, &(*tc_handler), result);

                                    *result = self->disable_event_action(EvID, event_action_ID);

                                    var tm_handler2 : Option<box TMHandlerT> = None;
                                    self->a_tm_handler_pool.alloc(&mut tm_handler2);

                                    match tm_handler2 {

                                        case Some(b_tm_handler2) => {

                                            var tm_count2 : u16 = 0 : u16;
                                            self->tm_counter.get_next_tm_count(&mut tm_count2);
                                            build_tm_1_7(&mut b_tm_handler2, tm_count2, &(*tc_handler), result);
                                            self->tm_channel.send_tm(b_tm_handler2, result);
                                        }
                                        case None => {
                                            *result = Result::Error;
                                        }
                                    }

                            } else {

                                built_tm_1_4_ev_action_not_defined(&mut b_tm_handler, tm_count, &(*tc_handler), EvID, result);
                            }
                        } else {
                            
                            build_tm_1_4_EvID_not_valid(&mut b_tm_handler, tm_count, &(*tc_handler), EvID, result);
                        }
                    }
                }
                self->tm_channel.send_tm(b_tm_handler, result);
            }
            case None => {
                *result = Result::Error;
            }
        }

        return; 
    }

    

/*
    procedure manage_event_actions(&mut self, event_list: &mut EventList){

        for i : usize in 0 .. max_num_events while (i < event_list->num_events){
                
            var event_info : EventInfo = {ev_RID = 0, ev_aux_data = [0; event_aux_data_max_size], ev_aux_data_size = 0};
            get_event_info(&(*event_list), i, &mut event_info);

            var RIDenabled : bool = false;
            self->pus_service_5.is_RID_enabled_ext(event_info.ev_RID, &mut RIDenabled);
        
            if(RIDenabled){

                var index : usize = 0;
                var enabled : bool = false;

                if (self->get_event_action_config(event_info.ev_RID, &mut index, &mut enabled)){

                    if(enabled){
                        //new pending event action
                
                        var RID_type : RIDType = get_RID_type(event_info.ev_RID);
                        var tail_index : usize = 0;

                        
                        match RID_type {
                            case Informative => {
                                
                                tail_index = (self->pending_action_head[0] + self->pending_action_number[0])%event_action_queue_dimension;
                                self->pending_action_queue_1I[tail_index] = self->event_action_packets[index];
                                self->pending_action_number[0] = self->pending_action_number[0] + 1;
                            
                            }
                            case LowSeverityAnomaly => {

                                tail_index = (self->pending_action_head[1] + self->pending_action_number[1])%event_action_queue_dimension;
                                self->pending_action_queue_2LS[tail_index] = self->event_action_packets[index];
                                self->pending_action_number[1] = self->pending_action_number[1] + 1;
                                
                            }
                            case MediumSeverityAnomaly => {

                                tail_index = (self->pending_action_head[2] + self->pending_action_number[2])%event_action_queue_dimension;
                                self->pending_action_queue_3MS[tail_index] = self->event_action_packets[index];
                                self->pending_action_number[2] = self->pending_action_number[2] +1;
                                
                            }
                            case HighSeverityAnomaly => {

                                tail_index = (self->pending_action_head[3] + self->pending_action_number[3])%event_action_queue_dimension;
                                self->pending_action_queue_4HS[tail_index] = self->event_action_packets[index];
                                self->pending_action_number[3] = self->pending_action_number[3] +1;
                            
                            }
                            case RIDNotValid => {

                                //error
                                
                            }
                        }
                        
                    } else {
                        
                    }
                }   
              
                
            }
        
    }
        

        clear_ev_list(event_list);

        return;
    }*/

     procedure manage_event_action(&mut self){

                
            var event_info : EventInfo = {ev_RID = 0, ev_aux_data = [0; event_aux_data_max_size], ev_aux_data_size = 0};
            get_event_info(&(*event_list), i, &mut event_info);

            var RIDenabled : bool = false;
            self->pus_service_5.is_RID_enabled_ext(event_info.ev_RID, &mut RIDenabled);
        
            if(RIDenabled){

                var index : usize = 0;
                var enabled : bool = false;

                if (self->get_event_action_config(event_info.ev_RID, &mut index, &mut enabled)){

                    if(enabled){
                        //new pending event action
                
                        var RID_type : RIDType = get_RID_type(event_info.ev_RID);
                        var tail_index : usize = 0;

                        
                        match RID_type {
                            case Informative => {
                                
                                tail_index = (self->pending_action_head[0] + self->pending_action_number[0])%event_action_queue_dimension;
                                self->pending_action_queue_1I[tail_index] = self->event_action_packets[index];
                                self->pending_action_number[0] = self->pending_action_number[0] + 1;
                            
                            }
                            case LowSeverityAnomaly => {

                                tail_index = (self->pending_action_head[1] + self->pending_action_number[1])%event_action_queue_dimension;
                                self->pending_action_queue_2LS[tail_index] = self->event_action_packets[index];
                                self->pending_action_number[1] = self->pending_action_number[1] + 1;
                                
                            }
                            case MediumSeverityAnomaly => {

                                tail_index = (self->pending_action_head[2] + self->pending_action_number[2])%event_action_queue_dimension;
                                self->pending_action_queue_3MS[tail_index] = self->event_action_packets[index];
                                self->pending_action_number[2] = self->pending_action_number[2] +1;
                                
                            }
                            case HighSeverityAnomaly => {

                                tail_index = (self->pending_action_head[3] + self->pending_action_number[3])%event_action_queue_dimension;
                                self->pending_action_queue_4HS[tail_index] = self->event_action_packets[index];
                                self->pending_action_number[3] = self->pending_action_number[3] +1;
                            
                            }
                            case RIDNotValid => {

                                //error
                                
                            }
                        }
                        
                    } else {
                        
                    }
                }   
              
                
            
        
    }
        

        return;
    }

    procedure get_pending_action_number(&mut self, paction_num : &mut[usize;4]){

        for i: usize in 0 .. 3 {

            paction_num[i] = self->pending_action_number[i];

        }

        return;
    }

    procedure extract_action (&mut self, index : usize, action_packet : &mut TCDescriptorT){

        if (index == 0){

            *action_packet = self->pending_action_queue_1I[self->pending_action_head[0]];

        } else if (index == 1){

            *action_packet = self->pending_action_queue_2LS[self->pending_action_head[1]];

        } else if (index == 2){

            *action_packet = self->pending_action_queue_3MS[self->pending_action_head[2]];

        } else if (index == 3){

            *action_packet = self->pending_action_queue_4HS[self->pending_action_head[3]];

        } else {
            //error
        } 

        return;

    }

    


};








