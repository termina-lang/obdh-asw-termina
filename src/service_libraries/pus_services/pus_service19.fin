/*
PUS SERVICE 19 : EVENT-ACTION
*/

import service_libraries.pus_services.pus_service5.pus_service5;
import service_libraries.pus_services.pus_service1.pus_service1;
import service_libraries.serialize;
import service_libraries.tc_ccsds_pus_format;
import service_libraries.tm_ccsds_pus_format;
import service_libraries.event_list;
const event_action_max_bytes : usize = 242;


const max_event_action_definitions : usize = 16;
const event_action_queue_dimension : usize = 8;


struct EventActionConfig {
    enabled: bool;
    event_ID: u16;
};



interface PUSS19Iface {

    procedure exec19_1TC (&mut self, tc_descriptor: &TCDescriptorT , result: &mut Result);
    procedure exec19_2TC (&mut self, tc_descriptor: &TCDescriptorT , result: &mut Result);
    procedure exec19_4TC (&mut self, tc_descriptor: &TCDescriptorT , result: &mut Result);
    procedure exec19_5TC (&mut self, tc_descriptor: &TCDescriptorT , result: &mut Result);
    procedure manage_event_actions(&mut self, event_list: &mut EventList);
    procedure get_pending_action_number(&mut self, paction_num : &mut[usize;4]);
    procedure extract_action (&mut self, index : usize, action_packet : &mut TCDescriptorT);
    
};

resource class PUSService19 provides PUSS19Iface {

    event_action_config : [EventActionConfig; max_event_action_definitions];
    event_action_packets : [TCDescriptorT; max_event_action_definitions];
   
    pending_action_queue_1I : [TCDescriptorT; event_action_queue_dimension];
    pending_action_queue_2LS : [TCDescriptorT; event_action_queue_dimension];
    pending_action_queue_3MS : [TCDescriptorT; event_action_queue_dimension];
    pending_action_queue_4HS : [TCDescriptorT; event_action_queue_dimension];
    
    pending_action_number : [usize; 4];
    pending_action_head : [usize; 4];
   
    pus_service_5 : access PUSS5Iface;

    tm_channel: access TMChannelIface;   
    a_tm_descriptor_pool : access Allocator<TMDescriptorT>;
    tm_counter : access TMCounterIface;


    viewer get_event_action_config (&self, evID: u16, index: &mut usize, enabled: &mut bool) -> bool {

        var found: bool = false;

        for i : usize in 0 .. max_event_action_definitions while found == false {

            if (self->event_action_config[i].event_ID == evID) {

                    *index = i;
                    *enabled = self->event_action_config[i].enabled;
                    found = true;
            }
        }
        return found;
    }

    viewer get_free_event_action_index (&self, index: &mut usize)->bool {

        var found: bool = false;

        for i : usize in 0 .. max_event_action_definitions while found == false {

            if (self->event_action_config[i].event_ID == 0) {

                *index = i;
                found = true;
            }
        }
        return found;
    }

    //TC[19,1] allows the addition of event-action definitions
    procedure exec19_1TC (&mut self, tc_descriptor: &TCDescriptorT , result: &mut Result){

        var tm_descriptor : Option<box TMDescriptorT> = None;
        self->a_tm_descriptor_pool.alloc(&mut tm_descriptor);

        match tm_descriptor {

            case Some(descriptor) => {

                var tm_count : u16 = 0 : u16;
                self->tm_counter.get_next_tm_count(&mut tm_count);

                var index : usize = 0;
                var found : bool = false;
                var enabled : bool = false;
                var evID : u16 = deserialize_uint16(&(tc_descriptor->tc_bytes[10 : usize .. 12 : usize]));
                var event_type : RIDType = get_RID_type(evID);

                if(event_type is RIDType::RIDNotValid){

                    build_tm_1_8_tc_5_X_RIDunknown(&mut descriptor, tm_count, evID, tc_descriptor);
                                
                } else {
                    /*Here a function is used as a value. I think this souldn't work as Termina is not a higher-order programming language
                    The transpilation is right*/
                    if (self->get_event_action_config(evID, &mut index, &mut enabled)){

                        found = true;

                    } else {
                            
                        if (self->get_free_event_action_index(&mut index)){

                            found = true;
                            enabled = false;

                        } else {

                            found = false;

                        }
                    } 

                    if (found){

                        if (enabled){ //Event-action can't be redefined if it is enabled

                            build_tm_1_8_tc_19_X_event_action_enabled(&mut descriptor, tm_count, evID, tc_descriptor);

                        } else {

                            var action_packet_length : usize = get_packet_length(&(tc_descriptor->tc_bytes)) as usize - 7;
                            //TO CHECK 
                            
                            for i : usize in 0 .. event_action_max_bytes while i < action_packet_length {

                                self->event_action_packets[index].tc_bytes[i] = tc_descriptor->tc_bytes[i + 12];

                            }

                        self->event_action_packets[index].tc_num_bytes = action_packet_length;
                            
                            var tc_status : TCStatus = {
                                acceptation_status = TCAcceptationStatus::Undefined,
                                execution_status = TCExecutionCtrl::Undefined,
                                error_code =  TCErrorType::Undefined
                            };

                            tc_status = try_tc_acceptation(&(self->event_action_packets)[index]); //This will generate an error. I have to use TCDescriptorT for events

                            if (tc_status.acceptation_status is TCAcceptationStatus::Accepted){
                            
                                self->event_action_config[index].event_ID = evID;
                                self->event_action_config[index].enabled = false;
                                
                                build_tm_1_7(&mut descriptor, tm_count, tc_descriptor);
                            

                            } else {

                                build_tm_1_8_tc_19_1_event_action_rejected(&mut descriptor, tm_count, evID, tc_descriptor);

                            }
                        }         

                    } else {

                        //Not found means the maximun of event-action definitions has been reached
                        build_tm_1_8_tc_19_1_max_event_actions(&mut descriptor, tm_count, evID, tc_descriptor);

                    }
                }
                self->tm_channel.send_tm(descriptor, result);
            }
            case None => {
                //Error
                *result = Result::Error;
            }
        }

    return; 
    }


    //TC[19,2] allows the deletion of event-action definitions
    procedure exec19_2TC (&mut self, tc_descriptor: &TCDescriptorT , result: &mut Result){

        var tm_descriptor : Option<box TMDescriptorT> = None;
        self->a_tm_descriptor_pool.alloc(&mut tm_descriptor);

        match tm_descriptor {

            case Some(descriptor) => {

                var tm_count : u16 = 0 : u16;
                self->tm_counter.get_next_tm_count(&mut tm_count);

                var index : usize = 0;
                var enabled : bool = false;
                var evID : u16 = deserialize_uint16(&(tc_descriptor->tc_bytes[10 : usize .. 12 : usize]));
                var event_type : RIDType = get_RID_type(evID);

                if (event_type is RIDType::RIDNotValid){

                    build_tm_1_8_tc_5_X_RIDunknown(&mut descriptor, tm_count, evID, tc_descriptor);

                } else {

                    if (self->get_event_action_config(evID, &mut index, &mut enabled)){

                        if (enabled){
                                
                                build_tm_1_8_tc_19_X_event_action_enabled(&mut descriptor, tm_count, evID, tc_descriptor);
                
                            } else {
                
                                self->event_action_config[index].event_ID = 0;
                                self->event_action_config[index].enabled = false;
                
                                build_tm_1_7(&mut descriptor, tm_count, tc_descriptor);
                        }

                    } else {

                        build_tm_1_8_tc_19_X_event_action_not_defined(&mut descriptor, tm_count, evID, tc_descriptor);

                    }
                }
                self->tm_channel.send_tm(descriptor, result);
            }
            case None => {
                *result = Result::Error;
            }
        }

    return;              
    }


    //TC[19,4] allows enabling event-action definitions
    procedure exec19_4TC (&mut self, tc_descriptor: &TCDescriptorT , result: &mut Result){

        var tm_descriptor : Option<box TMDescriptorT> = None;
        self->a_tm_descriptor_pool.alloc(&mut tm_descriptor);

        match tm_descriptor {

            case Some(descriptor) => {

                var tm_count : u16 = 0 : u16;
                self->tm_counter.get_next_tm_count(&mut tm_count);

                var index : usize = 0;
                var enabled : bool = false;
                var evID : u16 = deserialize_uint16(&(tc_descriptor->tc_bytes[10 : usize .. 12 : usize]));
                var event_type : RIDType = get_RID_type(evID);

                if (event_type is RIDType::RIDNotValid){

                    build_tm_1_8_tc_5_X_RIDunknown(&mut descriptor, tm_count, evID, tc_descriptor);

                } else {

                    if (self->get_event_action_config(evID, &mut index, &mut enabled)){

                        self->event_action_config[index].enabled = true;
                        build_tm_1_7(&mut descriptor, tm_count, tc_descriptor);

                    } else {

                        build_tm_1_8_tc_19_X_event_action_not_defined(&mut descriptor, tm_count, evID, tc_descriptor);

                    }
                }
                self->tm_channel.send_tm(descriptor, result);
            }
            case None => {
                *result = Result::Error;
            }
        }
        return;
    }


    //TC[19,5] allows disabling event-action definitions
    procedure exec19_5TC (&mut self, tc_descriptor: &TCDescriptorT, result: &mut Result){

        var tm_descriptor : Option<box TMDescriptorT> = None;
        self->a_tm_descriptor_pool.alloc(&mut tm_descriptor);

        match tm_descriptor {

            case Some(descriptor) => {

                var tm_count : u16 = 0 : u16;
                self->tm_counter.get_next_tm_count(&mut tm_count);

                var index : usize = 0;
                var enabled : bool = false;
                var evID : u16 = deserialize_uint16(&(tc_descriptor->tc_bytes[10 : usize .. 12 : usize]));
                var event_type : RIDType = get_RID_type(evID);

                if (event_type is RIDType::RIDNotValid){

                    build_tm_1_8_tc_5_X_RIDunknown(&mut descriptor, tm_count, evID, tc_descriptor);

                } else {

                    if (self->get_event_action_config(evID, &mut index, &mut enabled)){

                        self->event_action_config[index].enabled = false;
                        build_tm_1_7(&mut descriptor, tm_count, tc_descriptor);

                    } else {

                        build_tm_1_8_tc_19_X_event_action_not_defined(&mut descriptor, tm_count, evID, tc_descriptor);

                    }
                }
                self->tm_channel.send_tm(descriptor, result);
            }
            case None => {
                *result = Result::Error;
            }
        }
        return;
    }

    


    procedure manage_event_actions(&mut self, event_list: &mut EventList){

        for i : usize in 0 .. max_num_events while (i < event_list->num_events){
                
            var event_info : EventInfo = {ev_RID = 0, ev_aux_data = [0; event_aux_data_max_size], ev_aux_data_size = 0};
            get_event_info(&(*event_list), i, &mut event_info);

            var RIDenabled : bool = false;
            self->pus_service_5.is_RID_enabled_ext(event_info.ev_RID, &mut RIDenabled);
        
            if(RIDenabled){

                var index : usize = 0;
                var enabled : bool = false;

                if (self->get_event_action_config(event_info.ev_RID, &mut index, &mut enabled)){

                    if(enabled){
                        //new pending event action
                
                        var RID_type : RIDType = get_RID_type(event_info.ev_RID);
                        var tail_index : usize = 0;

                        
                        match RID_type {
                            case Informative => {
                                
                                tail_index = (self->pending_action_head[0] + self->pending_action_number[0])%event_action_queue_dimension;
                                self->pending_action_queue_1I[tail_index] = self->event_action_packets[index];
                                self->pending_action_number[0] = self->pending_action_number[0] + 1;
                            
                            }
                            case LowSeverityAnomaly => {

                                tail_index = (self->pending_action_head[1] + self->pending_action_number[1])%event_action_queue_dimension;
                                self->pending_action_queue_2LS[tail_index] = self->event_action_packets[index];
                                self->pending_action_number[1] = self->pending_action_number[1] + 1;
                                
                            }
                            case MediumSeverityAnomaly => {

                                tail_index = (self->pending_action_head[2] + self->pending_action_number[2])%event_action_queue_dimension;
                                self->pending_action_queue_3MS[tail_index] = self->event_action_packets[index];
                                self->pending_action_number[2] = self->pending_action_number[2] +1;
                                
                            }
                            case HighSeverityAnomaly => {

                                tail_index = (self->pending_action_head[3] + self->pending_action_number[3])%event_action_queue_dimension;
                                self->pending_action_queue_4HS[tail_index] = self->event_action_packets[index];
                                self->pending_action_number[3] = self->pending_action_number[3] +1;
                            
                            }
                            case RIDNotValid => {

                                //error
                                
                            }
                        }
                        
                    } else {
                        
                    }
                }   
              
                
            }
        
    }
        

        clear_ev_list(event_list);

        return;
    }

    procedure get_pending_action_number(&mut self, paction_num : &mut[usize;4]){

        for i: usize in 0 .. 3 {

            paction_num[i] = self->pending_action_number[i];

        }

        return;
    }

    procedure extract_action (&mut self, index : usize, action_packet : &mut TCDescriptorT){

        if (index == 0){

            *action_packet = self->pending_action_queue_1I[self->pending_action_head[0]];

        } else if (index == 1){

            *action_packet = self->pending_action_queue_2LS[self->pending_action_head[1]];

        } else if (index == 2){

            *action_packet = self->pending_action_queue_3MS[self->pending_action_head[2]];

        } else if (index == 3){

            *action_packet = self->pending_action_queue_4HS[self->pending_action_head[3]];

        } else {
            //error
        } 

        return;

    }

    


};








