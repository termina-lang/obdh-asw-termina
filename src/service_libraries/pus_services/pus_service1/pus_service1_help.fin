import service_libraries.tc_ccsds_pus_format;
import service_libraries.tm_ccsds_pus_format;
import service_libraries.crc;
import service_libraries.serialize;
import service_libraries.pus_tc_handler;
import service_libraries.pus_tm_handler;


const ACCEPT_ACK_ENABLED_MASK : u8 = 0x01;
const EXEC_START_ACK_ENABLED_MASK : u8 = 0x02;
const EXEC_PROGRESS_ACK_ENABLED_MASK : u8 = 0x04;
const EXEC_COMPLETION_ACK_ENABLED_MASK : u8 = 0x08;

enum TCAcceptationStatus {
	Accepted,
	Rejected,
	Undefined
};

//Error types for TM[1,2] packets
enum TCErrorType {
	CRCError,
	APIDError,
	SourceIDError,
	TypeError,
	SubTypeError,
	Undefined
};

enum TCExecutionCtrl {
    ExecCtrlPrioTC, ExecCtrlHK_FDIRTC, ExecCtrlBKGTC, Undefined
};


struct TCStatus {
	acceptation_status : TCAcceptationStatus;
    execution_status : TCExecutionCtrl;
	error_code : TCErrorType;
};

enum TCVerifyStage {
	Acceptation, ExecStart, Progress, ExecCompletion
};


function is_crc_valid(tc_descriptor : &TCDescriptorT) -> bool {

	let cal_crc_value : u16 = cal_crc_16(&(tc_descriptor->tc_bytes), (tc_descriptor->tc_num_bytes - 2));
	var packet_error_ctrl : u16 = get_packet_seq_ctrl(&(tc_descriptor->tc_bytes));

	var is_valid : bool = (cal_crc_value == packet_error_ctrl);

	return is_valid;
}


function is_apid_valid(tc_descriptor : &TCDescriptorT) -> bool {
	
	let epd_apid : u16 = 0x32C : u16;
	var tc_apid : u16 = get_APID(&(tc_descriptor->tc_bytes));
	
	var is_valid : bool = (epd_apid == tc_apid);

	return is_valid;
}


function is_sourceID_valid(tc_descriptor : &TCDescriptorT) -> bool {
	
	let System_SourceID : u16 = 0x78;

	var sourceID : u16 = get_source_id(&(tc_descriptor->tc_bytes));

	var is_valid : bool = (System_SourceID == sourceID);

	return is_valid;
}

function is_tc_ack_accept_enabled(flags_ack : u8) -> bool{

	var ack_enabled : bool = false;

	if ((flags_ack & ACCEPT_ACK_ENABLED_MASK) != 0) {
		ack_enabled = true;
	}
	return ack_enabled;

}

function is_tc_ack_start_exec_enabled(flags_ack : u8) -> bool{

	var ack_enabled : bool = false;
	
	if ((flags_ack & EXEC_START_ACK_ENABLED_MASK) != 0) {
		ack_enabled = true;
	}
	return ack_enabled;

}

function is_tc_ack_progress_exec_enabled(flags_ack : u8) -> bool{

	var ack_enabled : bool = false;
	
	if ((flags_ack & EXEC_PROGRESS_ACK_ENABLED_MASK) != 0) {
		ack_enabled = true;
	}
	return ack_enabled;

}

function is_tc_ack_completion_exec_enabled(flags_ack : u8) -> bool{

	var ack_enabled : bool = false;
	
	if ((flags_ack & EXEC_COMPLETION_ACK_ENABLED_MASK) != 0) {
		ack_enabled = true;
	}
	return ack_enabled;

}


function get_failure_subtype (verify_stage : TCVerifyStage) -> u8 {

	var subtype : u8 = 0;

	match verify_stage {
		case Acceptation => {
			subtype = 2;
		}
		case ExecStart => {
			subtype = 4;
		}
		case Progress => {
			subtype = 6;
		}
		case ExecCompletion => {
			subtype = 8;
		}
	}

	return subtype;
}


function build_tm_1_X_no_failure_data(p_tm_handler : &mut TMHandlerT, tm_seq_counter : u16, tc_packet_id : u16, 
			tc_packet_error_ctrl: u16, verify_stage : TCVerifyStage, failure_code : u8, current_obt : MissionObt, result : &mut MyResult) {

	var subtype : u8 = get_failure_subtype(verify_stage);

	startup_tm(p_tm_handler);
	append_u16_appdata_field(p_tm_handler, tc_packet_id, result);
	append_u16_appdata_field(p_tm_handler, tc_packet_error_ctrl, result);
	append_u8_appdata_field(p_tm_handler, failure_code, result);
	close_tm(p_tm_handler, 1, subtype, tm_seq_counter, current_obt);

	return;
}


function build_tm_1_X_u8_failure_data(p_tm_handler : &mut TMHandlerT, tm_seq_counter : u16, tc_packet_id : u16,
		 tc_packet_error_ctrl: u16, verify_stage : TCVerifyStage, failure_code : u8, failure_data : u8, current_obt : MissionObt, result : &mut MyResult) {

	var subtype : u8 = get_failure_subtype(verify_stage);

	startup_tm(p_tm_handler);
	append_u16_appdata_field(p_tm_handler, tc_packet_id, result);
	append_u16_appdata_field(p_tm_handler, tc_packet_error_ctrl, result);
	append_u8_appdata_field(p_tm_handler, failure_code, result);
	append_u8_appdata_field(p_tm_handler, failure_data, result);
	close_tm(p_tm_handler, 1, subtype, tm_seq_counter, current_obt);

	return;
}



function build_tm_1_X_u16_failure_data(p_tm_handler : &mut TMHandlerT, tm_seq_counter : u16, tc_packet_id : u16,
		 tc_packet_error_ctrl: u16, verify_stage : TCVerifyStage, failure_code : u8, failure_data : u16, current_obt : MissionObt, result : &mut MyResult) {

	var subtype : u8 = get_failure_subtype(verify_stage);

	startup_tm(p_tm_handler);
	append_u16_appdata_field(p_tm_handler, tc_packet_id, result);
	append_u16_appdata_field(p_tm_handler, tc_packet_error_ctrl, result);
	append_u8_appdata_field(p_tm_handler, failure_code, result);
	append_u16_appdata_field(p_tm_handler, failure_data, result);
	close_tm(p_tm_handler, 1, subtype, tm_seq_counter, current_obt);

	return;
}



function build_tm_1_X_u32_failure_data(p_tm_handler : &mut TMHandlerT, tm_seq_counter : u16, tc_packet_id : u16, tc_packet_error_ctrl: u16,
		 verify_stage : TCVerifyStage, failure_code : u8, failure_data : u32, current_obt : MissionObt, result : &mut MyResult) {

	var subtype : u8 = get_failure_subtype(verify_stage);

	startup_tm(p_tm_handler);
	append_u16_appdata_field(p_tm_handler, tc_packet_id, result);
	append_u16_appdata_field(p_tm_handler, tc_packet_error_ctrl, result);
	append_u8_appdata_field(p_tm_handler, failure_code, result);
	append_u32_appdata_field(p_tm_handler, failure_data, result);
	close_tm(p_tm_handler, 1, subtype, tm_seq_counter, current_obt);

	return;
}


function build_tm_1_X_u8_u32_failure_data(p_tm_handler : &mut TMHandlerT, tm_seq_counter : u16, tc_packet_id : u16, tc_packet_error_ctrl: u16,
 					verify_stage : TCVerifyStage, failure_code : u8, failure_data1 : u8, failure_data2 : u32, current_obt : MissionObt, result : &mut MyResult) {

	var subtype : u8 = get_failure_subtype(verify_stage);

	startup_tm(p_tm_handler);
	append_u16_appdata_field(p_tm_handler, tc_packet_id, result);
	append_u16_appdata_field(p_tm_handler, tc_packet_error_ctrl, result);
	append_u8_appdata_field(p_tm_handler, failure_code, result);
	append_u8_appdata_field(p_tm_handler, failure_data1, result);
	append_u32_appdata_field(p_tm_handler, failure_data2, result);
	close_tm(p_tm_handler, 1, subtype, tm_seq_counter, current_obt);

	return;
}


