/*
PUS SERVICE 12 : ON-BOARD MONITORING
*/

import service_libraries.pus_services.pus_service12.pus_service12_help;


interface PUSS12Iface {
    procedure do_monitoring (&mut self, event_list : &mut EventList, result : &mut Result);
    procedure exec12_1TC(&mut self, tc_descriptor: &TCDescriptorT ,result: &mut Result);
    procedure exec12_2TC(&mut self, tc_descriptor: &TCDescriptorT , result: &mut Result);
    procedure exec12_5TC(&mut self, tc_descriptor: &TCDescriptorT , result: &mut Result);
};



resource class PUSService12 provides PUSS12Iface {

    param_mon_config_table : [ParamMonitoringConfiguration; max_num_pmon_ids];
    param_limit_check_definition : [ParamLimitCheckDefinition; max_num_pmon_ids];

    system_data_pool : access AtomicArrayAccess<u16; sdp_num_params>;

    tm_channel : access TMChannelIface;
    a_tm_descriptor_pool : access Allocator<TMDescriptorT>;
    tm_counter : access TMCounterIface;


    procedure do_monitoring (&mut self, event_list : &mut EventList, result : &mut Result){ 

        for i : usize in 0 .. max_num_pmon_ids {

            if(self->param_mon_config_table[i].enabled == true){

                var PID : u16 = self->param_mon_config_table[i].PID;
                var SDP_value : u16 = 0;
                self->system_data_pool.load_index(PID as usize, &mut SDP_value);

                if(self->param_mon_config_table[i].interval_control >= self->param_mon_config_table[i].interval){

                    self->param_mon_config_table[i].interval_control = 0;

                    if(self->param_mon_config_table[i].state is CheckState::MonitorUnselected == false){

                        if (self->param_mon_config_table[i].state is CheckState::MonitorAboveHighLimit == false) &&
                            (self->param_mon_config_table[i].state is CheckState::MonitorBelowLowLimit== false) {

                            if (SDP_value > self->param_limit_check_definition[i].high_limit){

                                trigger_event(event_list, self->param_limit_check_definition[i].high_limit_rid, PID, SDP_value,
                                        self->param_limit_check_definition[i].high_limit, result);
                                var updated_state : CheckState = CheckState::MonitorAboveHighLimit;
                                update_state(&mut (self->param_mon_config_table), i, updated_state);
                            
                            } else if (SDP_value < self->param_limit_check_definition[i].low_limit){

                                trigger_event(event_list, self->param_limit_check_definition[i].low_limit_rid, PID, SDP_value,
                                        self->param_limit_check_definition[i].low_limit, result);
                                var updated_state : CheckState = CheckState::MonitorBelowLowLimit;
                                update_state(&mut (self->param_mon_config_table), i, updated_state);

                            } else {

                                if (self->param_mon_config_table[i].state is CheckState::MonitorUnchecked){

                                    var updated_state : CheckState = CheckState::MonitorWithinLimits;
                                    update_state(&mut (self->param_mon_config_table), i, updated_state);

                                }
                            }
                        } else {

                        if (SDP_value < self->param_limit_check_definition[i].high_limit) &&
                            (SDP_value > self->param_limit_check_definition[i].low_limit){

                                var updated_state : CheckState = CheckState::MonitorWithinLimits;
                                update_state(&mut (self->param_mon_config_table), i, updated_state);
                            }
                        }
                    } else {

                        self->param_mon_config_table[i].interval_control = self->param_mon_config_table[i].interval_control + 1;
                    }
                }

            }

        }

        return;   
    }


    procedure exec12_1TC(&mut self, tc_descriptor: &TCDescriptorT , result: &mut Result){

        var tm_descriptor : Option<box TMDescriptorT> = None;
        self->a_tm_descriptor_pool.alloc(&mut tm_descriptor);

         match tm_descriptor {

            case Some(descriptor) => {

                var tm_count : u16 = 0 : u16;
                self->tm_counter.get_next_tm_count(&mut tm_count);

                 
                var PMONID : usize = tc_descriptor->tc_bytes[10] as usize;

                if (PMONID < max_num_pmon_ids) {

                    if(self->param_mon_config_table[PMONID].state is CheckState::MonitorUnselected == false){

                        self->param_mon_config_table[PMONID].enabled = true;
                        self->param_mon_config_table[PMONID].interval_control = 0;
                        build_tm_1_7(&mut descriptor, tm_count, tc_descriptor);
                    } else {

                        build_tm_1_8_tc_12_X_PMONIDundefined(&mut descriptor, tm_count, PMONID as u16, tc_descriptor);
                    }
                } else {

                    build_tm_1_8_tc_12_X_PMONIDnotvalid(&mut descriptor, tm_count, PMONID as u16, tc_descriptor);
                }
                self->tm_channel.send_tm(descriptor, result);
            }
            case None => {
                *result = Result::Error;
            }
         }
        return;
    }


    procedure exec12_2TC(&mut self, tc_descriptor: &TCDescriptorT , result: &mut Result){
        
        var tm_descriptor : Option<box TMDescriptorT> = None;
        self->a_tm_descriptor_pool.alloc(&mut tm_descriptor);

         match tm_descriptor {

            case Some(descriptor) => {

                var tm_count : u16 = 0 : u16;
                self->tm_counter.get_next_tm_count(&mut tm_count);

                var PMONID : usize = tc_descriptor->tc_bytes[10] as usize;

                if (PMONID < max_num_pmon_ids) {

                    if(self->param_mon_config_table[PMONID].state is CheckState::MonitorUnselected == false){

                        self->param_mon_config_table[PMONID].enabled = false;
                        build_tm_1_7(&mut descriptor, tm_count, tc_descriptor);
                        
                    } else {

                        build_tm_1_8_tc_12_X_PMONIDundefined(&mut descriptor, tm_count, PMONID as u16, tc_descriptor);
                    }
                } else {

                    build_tm_1_8_tc_12_X_PMONIDnotvalid(&mut descriptor, tm_count, PMONID as u16, tc_descriptor);
                }
                self->tm_channel.send_tm(descriptor, result);
            }
            case None => {
                *result = Result::Error;
            }
         }
        return;
    }


    procedure exec12_5TC(&mut self, tc_descriptor: &TCDescriptorT, result: &mut Result){

        var tm_descriptor : Option<box TMDescriptorT> = None;
        self->a_tm_descriptor_pool.alloc(&mut tm_descriptor);

         match tm_descriptor {

            case Some(descriptor) => {

                var tm_count : u16 = 0 : u16;
                self->tm_counter.get_next_tm_count(&mut tm_count);

                var PMONID : usize = deserialize_uint16(&(tc_descriptor->tc_bytes[10..12])) as usize;

                if (PMONID) < max_num_pmon_ids {

                    if(self->param_mon_config_table[PMONID].state is CheckState::MonitorUnselected) {

                        var PID : u16 = deserialize_uint16(&(tc_descriptor->tc_bytes[12..14]));

                        if (PID as usize < sdp_num_params) {

                            self->param_mon_config_table[PMONID].interval = tc_descriptor->tc_bytes[14];
                            self->param_mon_config_table[PMONID].PID = PID;
                            self->param_mon_config_table[PMONID].interval_control = 0;
                            self->param_mon_config_table[PMONID].state = CheckState::MonitorUnchecked;

                            self->param_limit_check_definition[PMONID].low_limit = deserialize_uint16(&(tc_descriptor->tc_bytes[15..17]));
                            self->param_limit_check_definition[PMONID].low_limit_rid = deserialize_uint16(&(tc_descriptor->tc_bytes[17..19]));
                            self->param_limit_check_definition[PMONID].high_limit = deserialize_uint16(&(tc_descriptor->tc_bytes[19..21]));
                            self->param_limit_check_definition[PMONID].high_limit_rid = deserialize_uint16(&(tc_descriptor->tc_bytes[21..23]));

                            build_tm_1_7(&mut descriptor, tm_count, tc_descriptor);

                        } else {

                            build_tm_1_8_tc_20_X_PIDnotvalid(&mut descriptor, tm_count, PID, tc_descriptor);
                        }
                    } else {

                        build_tm_1_8_tc_12_X_PMONIDdefined(&mut descriptor, tm_count, PMONID as u16, tc_descriptor);
                    }
                } else {

                    build_tm_1_8_tc_12_X_PMONIDnotvalid(&mut descriptor, tm_count, PMONID as u16, tc_descriptor);
                }
                self->tm_channel.send_tm(descriptor, result);
            }
            case None => {
                *result = Result::Error;
            }
         }

        return;

    }

     
};




