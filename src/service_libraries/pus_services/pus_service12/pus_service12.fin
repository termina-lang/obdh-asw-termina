/*
PUS SERVICE 12 : ON-BOARD MONITORING
*/

import service_libraries.pus_services.pus_service12.pus_service12_help;


interface PUSS12Iface {
    procedure do_monitoring (&mut self, event_list : &mut EventList, result : &mut Result);
    procedure exec12_1TC(&mut self, tc_descriptor: &TCDescriptorT , tm_descriptor: &mut TMDescriptorT, tm_seq_counter: u16);
    procedure exec12_2TC(&mut self, tc_descriptor: &TCDescriptorT , tm_descriptor: &mut TMDescriptorT, tm_seq_counter: u16);
    procedure exec12_5TC(&mut self, tc_descriptor: &TCDescriptorT , tm_descriptor: &mut TMDescriptorT, tm_seq_counter: u16);
};



resource class PUSService12 provides PUSS12Iface {

    param_mon_config_table : [ParamMonitoringConfiguration; max_num_pmon_ids];
    param_limit_check_definition : [ParamLimitCheckDefinition; max_num_pmon_ids];

    system_data_pool : access AtomicArrayAccess<u16; sdp_num_params>;


    procedure do_monitoring (&mut self, event_list : &mut EventList, result : &mut Result){ 

        for i : usize in 0 .. max_num_pmon_ids {

            if(self->param_mon_config_table[i].enabled == true){

                var PID : u16 = self->param_mon_config_table[i].PID;
                var SDP_value : u16 = 0;
                self->system_data_pool.load_index(PID as usize, &mut SDP_value);

                if(self->param_mon_config_table[i].interval_control >= self->param_mon_config_table[i].interval){

                    self->param_mon_config_table[i].interval_control = 0;

                    if(self->param_mon_config_table[i].state is CheckState::MonitorUnselected == false){

                        if (self->param_mon_config_table[i].state is CheckState::MonitorAboveHighLimit == false) &&
                            (self->param_mon_config_table[i].state is CheckState::MonitorBelowLowLimit== false) {

                            if (SDP_value > self->param_limit_check_definition[i].high_limit){

                                trigger_event(event_list, self->param_limit_check_definition[i].high_limit_rid, PID, SDP_value,
                                        self->param_limit_check_definition[i].high_limit, result);
                                var updated_state : CheckState = CheckState::MonitorAboveHighLimit;
                                update_state(&mut (self->param_mon_config_table), i, updated_state);
                            
                            } else if (SDP_value < self->param_limit_check_definition[i].low_limit){

                                trigger_event(event_list, self->param_limit_check_definition[i].low_limit_rid, PID, SDP_value,
                                        self->param_limit_check_definition[i].low_limit, result);
                                var updated_state : CheckState = CheckState::MonitorBelowLowLimit;
                                update_state(&mut (self->param_mon_config_table), i, updated_state);

                            } else {

                                if (self->param_mon_config_table[i].state is CheckState::MonitorUnchecked){

                                    var updated_state : CheckState = CheckState::MonitorWithinLimits;
                                    update_state(&mut (self->param_mon_config_table), i, updated_state);

                                }
                            }
                        } else {

                        if (SDP_value < self->param_limit_check_definition[i].high_limit) &&
                            (SDP_value > self->param_limit_check_definition[i].low_limit){

                                var updated_state : CheckState = CheckState::MonitorWithinLimits;
                                update_state(&mut (self->param_mon_config_table), i, updated_state);
                            }
                        }
                    } else {

                        self->param_mon_config_table[i].interval_control = self->param_mon_config_table[i].interval_control + 1;
                    }
                }

            }

        }

        return;   
    }


    procedure exec12_1TC(&mut self, tc_descriptor: &TCDescriptorT , tm_descriptor: &mut TMDescriptorT, tm_seq_counter: u16){
                 
        var PMONID : usize = tc_descriptor->tc_bytes[10] as usize;

        if (PMONID < max_num_pmon_ids) {

            if(self->param_mon_config_table[PMONID].state is CheckState::MonitorUnselected == false){

                self->param_mon_config_table[PMONID].enabled = true;
                self->param_mon_config_table[PMONID].interval_control = 0;
                build_tm_1_7(tm_descriptor, tm_seq_counter, tc_descriptor);
            } else {

                build_tm_1_8_tc_12_X_PMONIDundefined(tm_descriptor, tm_seq_counter, PMONID as u16, tc_descriptor);
            }
        } else {

            build_tm_1_8_tc_12_X_PMONIDnotvalid(tm_descriptor, tm_seq_counter, PMONID as u16, tc_descriptor);
        }
        return;
    }


    procedure exec12_2TC(&mut self, tc_descriptor: &TCDescriptorT , tm_descriptor: &mut TMDescriptorT, tm_seq_counter: u16){

        var PMONID : usize = tc_descriptor->tc_bytes[10] as usize;

        if (PMONID < max_num_pmon_ids) {

            if(self->param_mon_config_table[PMONID].state is CheckState::MonitorUnselected == false){

                self->param_mon_config_table[PMONID].enabled = false;
                build_tm_1_7(tm_descriptor, tm_seq_counter, tc_descriptor);
                
            } else {

                build_tm_1_8_tc_12_X_PMONIDundefined(tm_descriptor, tm_seq_counter, PMONID as u16, tc_descriptor);
            }
        } else {

            build_tm_1_8_tc_12_X_PMONIDnotvalid(tm_descriptor, tm_seq_counter, PMONID as u16, tc_descriptor);
        }
        return;
    }


    procedure exec12_5TC(&mut self, tc_descriptor: &TCDescriptorT , tm_descriptor: &mut TMDescriptorT, tm_seq_counter: u16){

        var PMONID : usize = deserialize_uint16(&(tc_descriptor->tc_bytes[10..12])) as usize;

        if (PMONID) < max_num_pmon_ids {

            if(self->param_mon_config_table[PMONID].state is CheckState::MonitorUnselected) {

                var PID : u16 = deserialize_uint16(&(tc_descriptor->tc_bytes[12..14]));

                if (PID as usize < sdp_num_params) {

                    self->param_mon_config_table[PMONID].interval = tc_descriptor->tc_bytes[14];
                    self->param_mon_config_table[PMONID].PID = PID;
                    self->param_mon_config_table[PMONID].interval_control = 0;
                    self->param_mon_config_table[PMONID].state = CheckState::MonitorUnchecked;

                    self->param_limit_check_definition[PMONID].low_limit = deserialize_uint16(&(tc_descriptor->tc_bytes[15..17]));
                    self->param_limit_check_definition[PMONID].low_limit_rid = deserialize_uint16(&(tc_descriptor->tc_bytes[17..19]));
                    self->param_limit_check_definition[PMONID].high_limit = deserialize_uint16(&(tc_descriptor->tc_bytes[19..21]));
                    self->param_limit_check_definition[PMONID].high_limit_rid = deserialize_uint16(&(tc_descriptor->tc_bytes[21..23]));

                    build_tm_1_7(tm_descriptor, tm_seq_counter, tc_descriptor);

                } else {

                    build_tm_1_8_tc_20_X_PIDnotvalid(tm_descriptor, tm_seq_counter, PID, tc_descriptor);
                }
            } else {

                build_tm_1_8_tc_12_X_PMONIDdefined(tm_descriptor, tm_seq_counter, PMONID as u16, tc_descriptor);
            }
        } else {

            build_tm_1_8_tc_12_X_PMONIDnotvalid(tm_descriptor, tm_seq_counter, PMONID as u16, tc_descriptor);
        }

        return;

    }

     
};




