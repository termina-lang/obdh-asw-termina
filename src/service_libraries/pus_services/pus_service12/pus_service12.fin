/*
PUS SERVICE 12 : ON-BOARD MONITORING
*/

import service_libraries.pus_services.pus_service12.pus_service12_help;


interface PUSS12Iface {
    procedure do_monitoring (&mut self, event_list : &mut EventList, result : &mut Result);
    procedure exec12_1TC(&mut self, tc_handler: &mut TCHandlerT, result: &mut Result);
    procedure exec12_2TC(&mut self, tc_handler: &mut TCHandlerT, result: &mut Result);
    procedure exec12_5TC(&mut self, tc_handler: &mut TCHandlerT, result: &mut Result);
    procedure exec12_6TC(&mut self, tc_handler: &mut TCHandlerT, result: &mut Result);
};



resource class PUSService12 provides PUSS12Iface {

    param_mon_config_table : [ParamMonitoringConfiguration; max_num_pmon_ids];

    system_data_pool : access AtomicArrayAccess<u16; sdp_num_params>;

    tm_channel : access TMChannelIface;
    a_tm_descriptor_pool : access Allocator<TMDescriptorT>;
    tm_counter : access TMCounterIface;



    procedure do_param_limits_monitoring (&mut self, event_list : &mut EventList, result : &mut Result){ 

        for i : usize in 0 .. max_num_pmon_ids {

            if(self->param_mon_config_table[i].enabled == true){

                var PID : u16 = self->param_mon_config_table[i].PID;
                var SDP_value : u16 = 0;
                self->system_data_pool.load_index(PID as usize, &mut SDP_value);

                if(self->param_mon_config_table[i].interval_control >= self->param_mon_config_table[i].interval){

                    self->param_mon_config_table[i].interval_control = 0;

                    if(self->param_mon_config_table[i].state is CheckState::MonitorUnselected == false){

                        if (self->param_mon_config_table[i].state is CheckState::MonitorAboveHighLimit == false) &&
                            (self->param_mon_config_table[i].state is CheckState::MonitorBelowLowLimit == false) {

                            if (SDP_value > self->param_limit_check_definition[i].high_limit){

                                trigger_event(event_list, self->param_limit_check_definition[i].high_limit_rid, PID, SDP_value,
                                        self->param_limit_check_definition[i].high_limit, result);
                                var updated_state : CheckState = CheckState::MonitorAboveHighLimit;
                                update_state(&mut (self->param_mon_config_table), i, updated_state);
                            
                            } else if (SDP_value < self->param_limit_check_definition[i].low_limit){

                                trigger_event(event_list, self->param_limit_check_definition[i].low_limit_rid, PID, SDP_value,
                                        self->param_limit_check_definition[i].low_limit, result);
                                var updated_state : CheckState = CheckState::MonitorBelowLowLimit;
                                update_state(&mut (self->param_mon_config_table), i, updated_state);

                            } else {

                                if (self->param_mon_config_table[i].state is CheckState::MonitorUnchecked){

                                    var updated_state : CheckState = CheckState::MonitorWithinLimits;
                                    update_state(&mut (self->param_mon_config_table), i, updated_state);

                                }
                            }
                        } else {

                        if (SDP_value < self->param_limit_check_definition[i].high_limit) &&
                            (SDP_value > self->param_limit_check_definition[i].low_limit){

                                var updated_state : CheckState = CheckState::MonitorWithinLimits;
                                update_state(&mut (self->param_mon_config_table), i, updated_state);
                            }
                        }
                    } else {

                        self->param_mon_config_table[i].interval_control = self->param_mon_config_table[i].interval_control + 1;
                    }
                }

            }

        }

        return;   
    }


    viewer get_PMON_type (&self, PMONID : usize) -> MonitorCheckType {

        var mon_type : MonitorCheckType = MonitorCheckType::Unselected;

        if (PMONID < max_num_pmon_ids) {

            mon_type = self->param_mon_config_table[PMONID as usize].monitor_type;
        }

        return mon_type;
    }

    procedure exec12_1TC(&mut self, tc_handler: &mut TCHandlerT , result: &mut Result){

        var tm_descriptor : Option<box TMDescriptorT> = None;
        self->a_tm_descriptor_pool.alloc(&mut tm_descriptor);

        match tm_descriptor {

            case Some(descriptor) => {

                var tm_count : u16 = 0 : u16;
                self->tm_counter.get_next_tm_count(&mut tm_count);

                var N : u8 = 0;
                var PMONID : u16 = 0;
                *result = tc_handler_get_u8_appdata_field(tc_handler, &mut N);
                *result = tc_handler_get_u16_appdata_field(tc_handler, &mut PMONID);

                if (result is Result::Error){

                    build_tm_1_4_short_pack_length(&mut descriptor, tm_count, tc_handler);
                } 
                else {

                    if (N != 1) {

                      build_tm_1_4_num_of_instr_not_valid(&mut descriptor, tm_count, tc_handler, N);
                    }
                    else {

                        var is_valid_PMONID : bool = PMONID < max_num_pmon_ids;

                        if (is_valid_PMONID) {

                            if(self->param_mon_config_table[PMONID as usize].state is CheckState::MonitorUnselected == false){

                                build_tm_1_3(&mut descriptor, tm_count, tc_handler);
                                self->param_mon_config_table[PMONID as usize].enabled = true;
                                self->param_mon_config_table[PMONID as usize].interval_control = 0;
                                self->param_mon_config_table[PMONID as usize].repetition_control = 0;

                                var tm_descriptor2 : Option<box TMDescriptorT> = None;
                                self->a_tm_descriptor_pool.alloc(&mut tm_descriptor2);

                                match tm_descriptor2 {

                                    case Some(descriptor2) => {

                                        var tm_count2 : u16 = 0 : u16;
                                        self->tm_counter.get_next_tm_count(&mut tm_count2);

                                        build_tm_1_7(&mut descriptor2, tm_count2, tc_handler);
                                    }
                                    case None => {
                                        *result = Result::Error;
                                    }
                                }

                            } else {

                                build_tm_1_4_PMON_undefined(&mut descriptor, tm_count, tc_handler, PMONID);
                            }
                        } else {

                            build_tm_1_4_PMONID_invalid(&mut descriptor, tm_count, tc_handler, PMONID);
                        }
                    }
                        self->tm_channel.send_tm(descriptor, result);

                        if(is_valid_PMONID) {
                            self->tm_channel.send_tm(descriptor2, result);
                        }
                }
            }
            case None => {
                *result = Result::Error;
            }
         }
        return;
    }


    procedure exec12_2TC(&mut self, tc_handler: &mut TCHandlerT , result: &mut Result){
        
        var tm_descriptor : Option<box TMDescriptorT> = None;
        self->a_tm_descriptor_pool.alloc(&mut tm_descriptor);

        match tm_descriptor {

            case Some(descriptor) => {

                var tm_count : u16 = 0 : u16;
                self->tm_counter.get_next_tm_count(&mut tm_count);

                var N : u8 = 0;
                var PMONID : u16 = 0;
                *result = tc_handler_get_u8_appdata_field(tc_handler, &mut N);
                *result = tc_handler_get_u16_appdata_field(tc_handler, &mut PMONID);

                if (result is Result::Error){

                    build_tm_1_4_short_pack_length(&mut descriptor, tm_count, tc_handler);
                } 
                else {

                    if (N != 1) {

                      build_tm_1_4_num_of_instr_not_valid(&mut descriptor, tm_count, tc_handler, N);
                    }
                    else {

                        var is_valid_PMONID : bool = PMONID < max_num_pmon_ids;

                        if (is_valid_PMONID) {

                            if(self->param_mon_config_table[PMONID as usize].state is CheckState::MonitorUnselected == false){

                                build_tm_1_3(&mut descriptor, tm_count, tc_handler);
                                self->param_mon_config_table[PMONID as usize].enabled = false;
                                set_unchecked(&mut (self->param_mon_config_table), PMONID as usize);

                                var tm_descriptor2 : Option<box TMDescriptorT> = None;
                                self->a_tm_descriptor_pool.alloc(&mut tm_descriptor2);

                                match tm_descriptor2 {

                                    case Some(descriptor2) => {

                                        var tm_count2 : u16 = 0 : u16;
                                        self->tm_counter.get_next_tm_count(&mut tm_count2);

                                        build_tm_1_7(&mut descriptor2, tm_count2, tc_handler);
                                    }
                                    case None => {
                                        *result = Result::Error;
                                    }
                                }

                            } else {

                                build_tm_1_4_PMON_undefined(&mut descriptor, tm_count, tc_handler, PMONID);
                            }
                        } else {

                            build_tm_1_4_PMONID_invalid(&mut descriptor, tm_count, tc_handler, PMONID);
                        }
                    }
                        self->tm_channel.send_tm(descriptor, result);

                        if(is_valid_PMONID) {
                            self->tm_channel.send_tm(descriptor2, result);
                        }
                }
            }
            case None => {
                *result = Result::Error;
            }
         }
        return;
    }


    procedure exec12_5TC(&mut self, tc_handler: &mut TCHandlerT, result: &mut Result){

        var tm_descriptor : Option<box TMDescriptorT> = None;
        self->a_tm_descriptor_pool.alloc(&mut tm_descriptor);

        var send_flag : bool = false;

         match tm_descriptor {

            case Some(descriptor) => {

                var tm_count : u16 = 0 : u16;
                self->tm_counter.get_next_tm_count(&mut tm_count);

                var N : u8 = 0;
                var PMONID : u16 = 0;
                var mon_config : ParamMonitoringConfiguration = {
                    PID = 0,
                    monitor_type = MonitorCheckType::Unselected,
                    enabled = false,
                    monitor_definition = MonitorDefinition::Unselected,
                    repetition = 0,
                    repetition_control = 0,
                    interval = 0,
                    interval_control = 0,
                    transitionY2K = {0,0},
                    temp_state = CheckState::Unselected,
                    state = CheckState::Unselected
                };
                var aux : u8 = 0;
               

                *result = tc_handler_get_u8_appdata_field(tc_handler, &mut N);
                *result = tc_handler_get_u16_appdata_field(tc_handler, &mut PMONID);
                *result = tc_handler_get_u16_appdata_field(tc_handler, &mut mon_config.PID);
                *result = tc_handler_get_u8_appdata_field(tc_handler, &mut mon_config.interval);
                *result = tc_handler_get_u8_appdata_field(tc_handler, &mut mon_config.repetition);
                *result = tc_handler_get_u8_appdata_field(tc_handler, &mut aux);
                mon_config.type = get_check_type(aux);

                if (result is Result::Error) {

                    build_tm_1_4_short_pack_length(&mut descriptor, tm_count, tc_handler);

                } else if (N != 1) {

                    build_tm_1_4_num_of_instr_not_valid(&mut descriptor, tm_count, tc_handler, N);

                } else if (mon_config.type is DataPoolItemType::NoValidPID) {

                    build_tm_1_4_PID_not_valid(&mut descriptor, tm_count, tc_handler, PID);

                } else if (mon_config.type == Limits) {

                    *result = get_PMON_limit_check_definition(tc_handler, PID, &mut mon_config.limit_check_definition);

                    if (*result is Result::Error) {

                        build_tm_1_4_short_pack_length(&mut descriptor, tm_count, tc_handler);
                    }
                    else {

                        if(is_valid_check_limit_def(&mon_config.limit_check_definition)){

                            send_flag = true;

                            build_tm_1_3(&mut descriptor, tm_count, tc_handler);
                            add_valid_mng_mon_def (PMONID as usize, &mon_config, &mut self->param_monit_config_table);
                
                            var tm_descriptor2 : Option<box TMDescriptorT> = None;
                            self->a_tm_descriptor_pool.alloc(&mut tm_descriptor2);

                            match tm_descriptor2 {

                                case Some(descriptor2) => {

                                    var tm_count2 : u16 = 0 : u16;
                                    self->tm_counter.get_next_tm_count(&mut tm_count2);

                                    build_tm_1_7(&mut descriptor2, tm_count2, tc_handler);
                                }
                                case None => {
                                    *result = Result::Error;
                                }
                            }

                        } else {

                            build_tm_1_4_PMON_definition_invalid(&mut descriptor, tm_count, tc_handler, PMONID);
                        }

                    }

                } else if (mon_config.type == ExpectedValue) {

                    *result = get_PMON_expected_value_check_definition(tc_handler, PID, &mut mon_config.expected_value_check_definition);

                    if (result is Result::Error) {

                        build_tm_1_4_short_pack_length(&mut descriptor, tm_count, tc_handler);

                    } else {

                        send_flag = true;

                        build_tm_1_3(&mut descriptor, tm_count, tc_handler);
                        add_valid_mng_mon_def (PMONID as usize, &mon_config, &mut self->param_monit_config_table);
                
                        var tm_descriptor2 : Option<box TMDescriptorT> = None;
                        self->a_tm_descriptor_pool.alloc(&mut tm_descriptor2);

                        match tm_descriptor2 {

                            case Some(descriptor2) => {

                                var tm_count2 : u16 = 0 : u16;
                                self->tm_counter.get_next_tm_count(&mut tm_count2);

                                build_tm_1_7(&mut descriptor2, tm_count2, tc_handler);
                            }
                            case None => {
                                *result = Result::Error;
                            }
                        }

                    }
            
                } else {

                    build_tm_1_4_PMON_definition_invalid(&mut descriptor, tm_count, tc_handler, PMONID);
                }

                self->tm_channel.send_tm(descriptor, result);

                if(send_flag) {
                    self->tm_channel.send_tm(descriptor2, result);
                }
            }
            case None => {
                *result = Result::Error;
            }
        }

        return;

    }


    procedure exec12_6TC(&mut self, tc_handler: &mut TCHandlerT, result: &mut Result){

        var tm_descriptor : Option<box TMDescriptorT> = None;
        self->a_tm_descriptor_pool.alloc(&mut tm_descriptor);

        var send_flag : bool = false;

         match tm_descriptor {

            case Some(descriptor) => {

                var tm_count : u16 = 0 : u16;
                self->tm_counter.get_next_tm_count(&mut tm_count);

                var N : u8 = 0;
                var PMONID : u16 = 0;
                *result = tc_handler_get_u8_appdata_field(tc_handler, &mut N);
                *result = tc_handler_get_u16_appdata_field(tc_handler, &mut PMONID);

                if (*result is Result::Error){

                    build_tm_1_4_short_pack_length(&mut descriptor, tm_count, tc_handler);
                }
                else if (N != 1) {

                    build_tm_1_4_num_of_instr_not_valid(&mut descriptor, tm_count, tc_handler, N);
                }
                else {
                    
                    var PMON_type : MonitorCheckType = get_PMON_type(PMONID as usize);

                    if(PMON_tpye is MonitorCheckType::Unselected){

                        build_tm_1_4_PMON_undefined(&mut descriptor, tm_count, tc_handler, PMONID);

                    } else if (self->param_mon_config_table[PMONID as usize].enabled == false){ 

                        send_flag = true;

                        build_tm_1_3(&mut descriptor, tm_count, tc_handler);
                      
                        self->param_mon_config_table[PMONID as usize].type = MonitorCheckType::Unselected;

                        var tm_descriptor2 : Option<box TMDescriptorT> = None;
                        self->a_tm_descriptor_pool.alloc(&mut tm_descriptor2);

                        match tm_descriptor2 {

                            case Some(descriptor2) => {

                                var tm_count2 : u16 = 0 : u16;
                                self->tm_counter.get_next_tm_count(&mut tm_count2);

                                build_tm_1_7(&mut descriptor2, tm_count2, tc_handler);
                            }
                            case None => {
                                *result = Result::Error;
                            }
                        }
                    } else {

                        build_tm_1_4_PMON_enabled(&mut descriptor, tm_count, tc_handler, PMONID);
                    }

                    self->tm_channel.send_tm(descriptor, result);

                    if(send_flag) {
                        self->tm_channel.send_tm(descriptor2, result);
                    }
                }

               

            } case None => {

                *result = Result::Error;
            }
         }

        return;

    }

     
};




