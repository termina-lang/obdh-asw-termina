import service_libraries.tc_ccsds_pus_format;
import service_libraries.tm_ccsds_pus_format;
import service_libraries.serialize;
import service_libraries.pus_services.pus_service1.pus_service1;
import service_libraries.event_list;
import resources.system_data_pool;


const max_num_pmon_ids : usize = 8;
const max_num_transitions : usize = 1;


enum MonitorCheckType {
    ExpectedValue, //0
    Limits,  //1
    Delta,  //2
    Unselected   //3
};

struct ParamValueCheckDefinition {
    mask_value : DataPoolItemType;
    expected_value : DataPoolItemType;
    EvID : u16;
};

struct ParamLimitCheckDefinition {
    low_limit : DataPoolItemType;
    low_limit_evID : u16;
    high_limit : DataPoolItemType;
    high_limit_evID : u16;
};

struct ParamDeltaCheckDefinition {
    low_delta_threshold : u16;
    low_delta_EvID : u16;
    high_delta_threshold : u16;
    high_delta_EvID : u16;
    consecutive_delta_values : u8;
};

enum MonitorDefinition {
    ParamValueCheck(ParamValueCheckDefinition),
    ParamLimitCheck(ParamLimitCheckDefinition),
    ParamDeltaCheck(ParamDeltaCheckDefinition),
    Unselected
};

enum CheckValueStatus {
    MonitorUnchecked,
    MonitorValueUnexpected,
    MonitorValueExpected
};

enum CheckLimitsStatus {
    MonitorUnchecked,
    MonitorAboveHighLimit,
    MonitorBelowLowLimit,
    MonitorWithinLimits
};

enum CheckDeltaStatus {
    MonitorUnchecked,
    MonitorDeltaLow,
    MonitorDeltaHigh,
    MonitorDeltaWithin
};

enum CheckState {
    ParamValueStatus(CheckValueStatus),
    ParamLimitStatus(CheckLimitsStatus),
    ParamDeltaStatus(CheckDeltaStatus),
    Unselected
};


struct ParamMonitoringConfiguration {
    PID : u16;
    type : MonitorCheckType;
    enabled : bool;
    definition : MonitorDefinition;
    repetition: u8;
    repetition_control: u8;
    interval : u8;
    interval_control : u8;
    transition_obt : TimeVal;
    temp_state : CheckState;
    current_state : CheckState;
};

enum MonitorType {
    MonitorCheckTypeExpectedValue,
	MonitorCheckTypeLimits,
    MonitorCheckTypeDelta,
	MonitorFree
};

struct ParamMonitoringTransitions {
    PMONID : u16;
    PID : u16;
    type : MonitorType;
    mask_value : u32;
	limit_value : u32;
	new_value : u32;
	prev_status : CheckState;
	new_status : CheckState;
	trans_obt : TimeVal;

};

/*

function trigger_event(event_list : &mut EventList, RID: u16, PID: u16, PID_value: u16, limit: u16, res: &mut Result){

    var ev_info : EventInfo = {
        ev_RID = RID,
        ev_aux_data = [0;event_aux_data_max_size],
        ev_aux_data_size = 6
    };

    serialize_uint16(PID, &mut (ev_info.ev_aux_data[0..2]));
    serialize_uint16(PID_value, &mut (ev_info.ev_aux_data[2..4]));
    serialize_uint16(limit, &mut (ev_info.ev_aux_data[4..6]));

    var result : ListResult = add_event(event_list, ev_info);
    // Right now I am not doing anything with the result, but I could add a new state of non-triggerred. Ask Pablo
    if result is ListResult::ListFull {

        *res = Result::Error;

    } else {

        *res = Result::Ok;

    }
    return;

}
*/
/*

function update_state (param_mon_config_table : &mut [ParamMonitoringConfiguration; max_num_pmon_ids], PMONID: usize, new_state : CheckState){

    if (PMONID < max_num_pmon_ids){

        param_mon_config_table[PMONID].prev_state = param_mon_config_table[PMONID].state;
        param_mon_config_table[PMONID].state = new_state;
        clock_get_uptime(&mut param_mon_config_table[PMONID].transitionY2K);
    }

    return;
}*/

/*
function set_unchecked (param_mon_config_table : &mut [ParamMonitoringConfiguration; max_num_pmon_ids], valid_PMONID : usize) {

    match (param_mon_config_table[valid_PMONID].state) {

        case ParamValueStatus(CheckValueStatus) => {
            param_mon_config_table[valid_PMONID].state = CheckValueStatus::MonitorUnchecked;
        }
        case ParamLimitStatus(CheckLimitsStatus) => {
            param_mon_config_table[valid_PMONID].state = CheckLimitsStatus::MonitorUnselected;
        }
        case ParamDeltaStatus(CheckDeltaStatus) => {
            param_mon_config_table[valid_PMONID].state = CheckDeltaStatus::MonitorUnchecked;
        }
        case Unselected => {
            //Do nothing
        }
    }

    param_mon_config_table[valid_PMONID].temp_state = param_mon_config_table[valid_PMONID].state;

    return;
}
*/

function get_check_type (aux : u8) -> MonitorCheckType {

    var monitor_check : MonitorCheckType = MonitorCheckType::Unselected;

    if (aux == 0) {

        monitor_check = MonitorCheckType::ExpectedValue;

    } else if (aux == 1) {

        monitor_check = MonitorCheckType::Limits;

    } else if (aux == 2) {

        monitor_check = MonitorCheckType::Delta;

    } else {

        monitor_check = MonitorCheckType::Unselected;

    }

    return monitor_check;
}

function get_PMON_limit_check_definition (tc_handler : &mut TCHandlerT, PID : u16, param_limit_check_definition : &mut ParamLimitCheckDefinition) -> Result {

    var res : Result = Result::Ok;

    var type : DataPoolItemType = sys_data_pool_get_item_type(PID as usize);

    match type {

        case u8_t => {

            //get low limit
            res = tc_handler_get_u8_appdata_field(tc_handler, &mut (param_limit_check_definition->low_limit));

            //get low limit evID
            res = tc_handler_get_u16_appdata_field(tc_handler, &mut (param_limit_check_definition->low_limit_evID));

            //get high limit
            res = tc_handler_get_u8_appdata_field(tc_handler, &mut (param_limit_check_definition->high_limit));

            //get high limit evID
            res = tc_handler_get_u16_appdata_field(tc_handler, &mut (param_limit_check_definition->high_limit_evID));

        }
        case u32_t => {

            //get low limit
            res = tc_handler_get_u32_appdata_field(tc_handler, &mut param_limit_check_definition->low_limit);

            //get low limit evID
            res = tc_handler_get_u16_appdata_field(tc_handler, &mut param_limit_check_definition->low_limit_evID);

            //get high limit
            res = tc_handler_get_32_appdata_field(tc_handler, &mut param_limit_check_definition->high_limit);

            //get high limit evID
            res = tc_handler_get_u16_appdata_field(tc_handler, &mut param_limit_check_definition->high_limit_evID);

        }
        case NoValidPID => {
            res = Result::Error;
        }
    }

    
    return res;

}


function get_PMON_value_check_definition (tc_handler : &mut TCHandlerT, PID : u16, expected_value_check_definition : &mut ParamValueCheckDefinition) -> Result {

    var res : Result = Result::Ok;

    var type : DataPoolItemType = sys_data_pool_get_item_type(PID);

    match type {

        case u8_t => {

            //get mask
            res = tc_handler_get_u8_appdata_field(tc_handler, &mut expected_value_check_definition.mask_value);

            //get expected value
            res = tc_handler_get_u8_appdata_field(tc_handler, &mut expected_value_check_definition.expected_value);

            //get EvID
            res = tc_handler_get_u16_appdata_field(tc_handler, &mut expected_value_check_definition.EvID);

          

        }
        case u32_t => {

            //get mask
            res = tc_handler_get_u32_appdata_field(tc_handler, &mut expected_value_check_definition.mask_value);

            //get expected value
            res = tc_handler_get_u32_appdata_field(tc_handler, &mut expected_value_check_definition.expected_value);

            //get EvID
            res = tc_handler_get_u16_appdata_field(tc_handler, &mut expected_value_check_definition.EvID);

      

        }
        case NoValidPID => {
            res = Result::Error;
        }
    }

    
    return res;

}


function is_valid_check_limit_def (param_limit_check_definition : &ParamLimitCheckDefinition) -> bool {

    var res : bool = false;

    if (param_limit_check_definition->low_limit < param_limit_check_definition->high_limit) {

        res = true;

    }

    return res;

}

function add_valid_mng_mon_def (PMONID: usize, param_monit_config: &ParamMonitoringConfiguration,
                                 param_mon_config_table : &mut [ParamMonitoringConfiguration; max_num_pmon_ids]){

    *param_mon_config_table[PMONID] = *param_monit_config;

    *param_mon_config_table[PMONID].enabled = false;

    set_unchecked(param_mon_config_table, PMONID);

    return;
}


function manage_new_status (PMONID : u16, new_state : CheckState, r_param_mon_config_table : &mut [ParamMonitoringConfiguration; max_num_pmon_ids]) -> bool {

    var transition : bool = false;

    match (new_state) {

        case ParamValueStatus(new_check_val_state) =>{

            match (r_param_mon_config_table->current_state){

                case ParamValueStatus(current_check_val_state)=>{

                    if (new_check_val_state != current_check_val_state){

                        match (r_param_mon_config_table->temp_state) {

                            case ParamValueStatus(temp_check_val_state)=>{

                                if (new_check_val_state == temp_check_val_state){

                                    r_param_mon_config_table[PMONID]->repetition_control = r_param_mon_config_table[PMONID]->repetition_control + 1;

                                } else {

                                    r_param_mon_config_table[PMONID]->temp_state = new_check_val_state;
                                    r_param_mon_config_table[PMONID]->repetition_control = 1;
                                    //r_param_mon_config_table[PMONID]->transition_obt = /*get_current_time()*/;
                                }
                                 if( r_param_mon_config_table[PMONID]->repetition_control >= r_param_mon_config_table[PMONID]->repetition){

                                    //add monitoring transtion ??
                                    r_param_mon_config_table[PMONID]->repetition_control = 0;
                                    r_param_mon_config_table[PMONID]->current_state = check_val_state;
                                    transition = true;
                                }
                            }
                            case ParamLimitStatus(temp_check_limit_state)=>{
                            }
                            case ParamDeltaStatus(temp_check_delta_state)=>{
                            }
                            case Unselected=>{

                            }
                        }
                    }else {

                        r_param_mon_config_table[PMONID]->temp_state = new_check_val_state;
                        r_param_mon_config_table[PMONID]->repetition_control = 0;

                    }

                   

                }
                case ParamLimitStatus(check_limit_state)=>{

                }
                case ParamDeltaStatus(check_delta_state)=>{

                }
                case Unselected=>{

                }

            }



        }
        case ParamLimitStatus(new_check_limit_state) =>{

           match (r_param_mon_config_table->current_state){

                case ParamValueStatus(current_check_val_state)=>{

                }
                case ParamLimitStatus(current_check_limit_state)=>{

                    if (new_check_limit_state != current_check_limit_state){

                        match (r_param_mon_config_table->temp_state) {

                            case ParamValueStatus(temp_check_limit_state)=>{

                            }
                            case ParamLimitStatus(temp_check_limit_state)=>{

                                if (new_check_limit_state == temp_check_limit_state){

                                    r_param_mon_config_table[PMONID]->repetition_control = r_param_mon_config_table[PMONID]->repetition_control + 1;

                                } else {

                                    r_param_mon_config_table[PMONID]->temp_state = new_check_limit_state;
                                    r_param_mon_config_table[PMONID]->repetition_control = 1;
                                    //r_param_mon_config_table[PMONID]->transition_obt = /*get_current_time()*/;
                                }
                                 if( r_param_mon_config_table[PMONID]->repetition_control >= r_param_mon_config_table[PMONID]->repetition){

                                    //add monitoring transtion ??
                                    r_param_mon_config_table[PMONID]->repetition_control = 0;
                                    r_param_mon_config_table[PMONID]->current_state = check_limit_state;
                                    transition = true;
                                }
                            }
                            case ParamDeltaStatus(temp_check_delta_state)=>{
                            }
                            case Unselected=>{

                            }
                        }

                    } else {

                        r_param_mon_config_table[PMONID]->temp_state = new_check_limit_state;
                        r_param_mon_config_table[PMONID]->repetition_control = 0;

                     }
                }
                case ParamDeltaStatus(current_check_delta_state)=>{

                }
                case Unselected=>{

                }
           }
                   
        }
        case ParamDeltaStatus(check_delta_state) =>{
            //Not defined
        }
        case Unselected=>{

        }
    }

    return transition;

}
