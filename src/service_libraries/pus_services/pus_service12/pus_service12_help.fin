import service_libraries.tc_ccsds_pus_format;
import service_libraries.tm_ccsds_pus_format;
import service_libraries.serialize;
import service_libraries.pus_services.pus_service1.pus_service1;
import service_libraries.event_list;
import resources.system_data_pool;


const max_num_pmon_ids : usize = 8;



enum MonitorCheckType {
    ExpectedValue, //0
    Limits,  //1
    Delta,  //2
    Unselected   //3
};

struct ParamValueCheckDefinition {
    mask_value : DataPoolItemType;
    expected_value : DataPoolItemType;
    EvID : u16;
};

struct ParamLimitCheckDefinition {
    low_limit : DataPoolItemType;
    low_limit_evID : u16;
    high_limit : DataPoolItemType;
    high_limit_evID : u16;
};

struct ParamDeltaCheckDefinition {
    low_delta_threshold : u16;
    low_delta_EvID : u16;
    high_delta_threshold : u16;
    high_delta_EvID : u16;
    consecutive_delta_values : u8;
};

enum MonitorDefinition {
    ParamValueCheck(ParamValueCheckDefinition),
    ParamLimitCheck(ParamLimitCheckDefinition),
    ParamDeltaCheck(ParamDeltaCheckDefinition),
    Unselected
};

enum CheckValueStatus {
    MonitorUnchecked,
    MonitorValueUnexpected,
    MonitorValueExpected
};

enum CheckLimitsStatus {
    MonitorUnchecked,
    MonitorAboveHighLimit,
    MonitorBelowLowLimit,
    MonitorWithinLimits
};

enum CheckDeltaStatus {
    MonitorUnchecked,
    MonitorDeltaLow,
    MonitorDeltaHigh,
    MonitorDeltaWithin
};

enum CheckState {
    ParamValueStatus(CheckValueStatus),
    ParamLimitStatus(CheckLimitsStatus),
    ParamDeltaStatus(CheckDeltaStatus),
    Unselected
};


struct ParamMonitoringConfiguration {
    PID : u16;
    monitor_type : MonitorCheckType;
    enabled : bool;
    monitor_definition : MonitorDefinition;
    repetition: u8;
    repetition_control: u8;
    interval : u8;
    interval_control : u8;
    transitionY2K : TimeVal;
    temp_state : CheckState;
    state : CheckState;
};




function trigger_event(event_list : &mut EventList, RID: u16, PID: u16, PID_value: u16, limit: u16, res: &mut Result){

    var ev_info : EventInfo = {
        ev_RID = RID,
        ev_aux_data = [0;event_aux_data_max_size],
        ev_aux_data_size = 6
    };

    serialize_uint16(PID, &mut (ev_info.ev_aux_data[0..2]));
    serialize_uint16(PID_value, &mut (ev_info.ev_aux_data[2..4]));
    serialize_uint16(limit, &mut (ev_info.ev_aux_data[4..6]));

    var result : ListResult = add_event(event_list, ev_info);
    // Right now I am not doing anything with the result, but I could add a new state of non-triggerred. Ask Pablo
    if result is ListResult::ListFull {

        *res = Result::Error;

    } else {

        *res = Result::Ok;

    }
    return;

}


function update_state (param_mon_config_table : &mut [ParamMonitoringConfiguration; max_num_pmon_ids], PMONID: usize, new_state : CheckState){

    if (PMONID < max_num_pmon_ids){

        param_mon_config_table[PMONID].prev_state = param_mon_config_table[PMONID].state;
        param_mon_config_table[PMONID].state = new_state;
        clock_get_uptime(&mut param_mon_config_table[PMONID].transitionY2K);
    }

    return;
}

function set_unchecked (param_mon_config_table : &mut [ParamMonitoringConfiguration; max_num_pmon_ids], valid_PMONID : usize) {

    match (param_mon_config_table[valid_PMONID].state) {

        case ParamValueStatus(CheckValueStatus) => {
            param_mon_config_table[valid_PMONID].state = CheckValueStatus::MonitorUnchecked;
        }
        case ParamLimitStatus(CheckLimitsStatus) => {
            param_mon_config_table[valid_PMONID].state = CheckLimitsStatus::MonitorUnselected;
        }
        case ParamDeltaStatus(CheckDeltaStatus) => {
            param_mon_config_table[valid_PMONID].state = CheckDeltaStatus::MonitorUnchecked;
        }
        case Unselected => {
            //Do nothing
        }
    }

    param_mon_config_table[valid_PMONID].temp_state = param_mon_config_table[valid_PMONID].state;

    return;
}


function get_check_type (aux : u8) -> MonitorCheckType {

    var monitor_check : MonitorCheckType = MonitorCheckType::Unselected;

    if (aux == 0) {

        monitor_check = MonitorCheckType::ExpectedValue;

    } else if (aux == 1) {

        monitor_check = MonitorCheckType::Limits;

    } else if (aux == 2) {

        monitor_check = MonitorCheckType::Delta;

    } else {

        monitor_check = MonitorCheckType::Unselected;

    }

    return monitor_check;
}

function get_PMON_limit_check_definition (tc_handler : &mut TCHandlerT, PID : u16, param_limit_check_definition : &mut ParamLimitCheckDefinition) -> Result {

    var res : Result = Result::Ok;

    var type : DataPoolItemType = sys_data_pool_get_item_type(PID);

    match type {

        case u8_t => {

            //get low limit
            res = tc_handler_get_u8_appdata_field(tc_handler, &mut param_limit_check_definition.low_limit);

            //get low limit evID
            res = tc_handler_get_u16_appdata_field(tc_handler, &mut param_limit_check_definition.low_limit_evID);

            //get high limit
            res = tc_handler_get_u8_appdata_field(tc_handler, &mut param_limit_check_definition.high_limit);

            //get high limit evID
            res = tc_handler_get_u16_appdata_field(tc_handler, &mut param_limit_check_definition.high_limit_evID);

        }
        case u32_t => {

            //get low limit
            res = tc_handler_get_u32_appdata_field(tc_handler, &mut param_limit_check_definition.low_limit);

            //get low limit evID
            res = tc_handler_get_u16_appdata_field(tc_handler, &mut param_limit_check_definition.low_limit_evID);

            //get high limit
            res = tc_handler_get_32_appdata_field(tc_handler, &mut param_limit_check_definition.high_limit);

            //get high limit evID
            res = tc_handler_get_u16_appdata_field(tc_handler, &mut param_limit_check_definition.high_limit_evID);

        }
        case NoValidPID => {
            res = Result::Error;
        }
    }

    
    return res;

}


function get_PMON_value_check_definition (tc_handler : &mut TCHandlerT, PID : u16, expected_value_check_definition : &mut ParamValueCheckDefinition) -> Result {

    var res : Result = Result::Ok;

    var type : DataPoolItemType = sys_data_pool_get_item_type(PID);

    match type {

        case u8_t => {

            //get mask
            res = tc_handler_get_u8_appdata_field(tc_handler, &mut expected_value_check_definition.mask_value);

            //get expected value
            res = tc_handler_get_u8_appdata_field(tc_handler, &mut expected_value_check_definition.expected_value);

            //get EvID
            res = tc_handler_get_u16_appdata_field(tc_handler, &mut expected_value_check_definition.EvID);

          

        }
        case u32_t => {

            //get mask
            res = tc_handler_get_u32_appdata_field(tc_handler, &mut expected_value_check_definition.mask_value);

            //get expected value
            res = tc_handler_get_u32_appdata_field(tc_handler, &mut expected_value_check_definition.expected_value);

            //get EvID
            res = tc_handler_get_u16_appdata_field(tc_handler, &mut expected_value_check_definition.EvID);

      

        }
        case NoValidPID => {
            res = Result::Error;
        }
    }

    
    return res;

}


function is_valid_check_limit_def (param_limit_check_definition : &ParamLimitCheckDefinition) -> bool {

    var res : bool = false;

    if (param_limit_check_definition->low_limit < param_limit_check_definition->high_limit) {

        res = true;

    }

    return res;

}

function add_valid_mng_mon_def (PMONID: usize, param_monit_config: &ParamMonitoringConfiguration,
                                 param_mon_config_table : &mut [ParamMonitoringConfiguration; max_num_pmon_ids]){

    *param_mon_config_table[PMONID] = *param_monit_config;

    *param_mon_config_table[PMONID].enabled = false;

    set_unchecked(param_mon_config_table, PMONID);

    return;
}