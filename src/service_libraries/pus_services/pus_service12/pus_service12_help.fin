import service_libraries.tc_ccsds_pus_format;
import service_libraries.tm_ccsds_pus_format;
import service_libraries.serialize;
import service_libraries.pus_services.pus_service1.pus_service1;
import service_libraries.event_list;
import resources.system_data_pool;
import service_libraries.pus_tc_handler;


const max_num_pmon_ids : usize = 8;
const max_num_transitions : usize = 1;


enum MonitorCheckType {
    ExpectedValue, //0
    Limits,  //1
    Delta,  //2
    Free   //3
};

struct ParamValueCheckDefinition {
    mask_value : u32;
    expected_value : u32;
    EvID : u16;
};

struct ParamLimitCheckDefinition {
    low_limit : u32;
    low_limit_evID : u16;
    high_limit : u32;
    high_limit_evID : u16;
};

struct ParamDeltaCheckDefinition {
    low_delta_threshold : u16;
    low_delta_EvID : u16;
    high_delta_threshold : u16;
    high_delta_EvID : u16;
    consecutive_delta_values : u8;
};

enum MonitorDefinition {
    ParamValueCheck(ParamValueCheckDefinition),
    ParamLimitCheck(ParamLimitCheckDefinition),
    ParamDeltaCheck(ParamDeltaCheckDefinition),
    Unselected
};

enum CheckValueStatus {
    MonitorUnchecked, //1
    MonitorValueUnexpected, //2
    MonitorValueExpected  //3
};

enum CheckLimitsStatus {
    MonitorUnchecked,  //4
    MonitorAboveHighLimit,  //5
    MonitorBelowLowLimit,  //6
    MonitorWithinLimits  //7
};

enum CheckDeltaStatus {
    MonitorUnchecked,  //8
    MonitorDeltaLow,  //9
    MonitorDeltaHigh,  //10
    MonitorDeltaWithin  //11
};


enum CheckState {
    ParamValueStatus(CheckValueStatus),
    ParamLimitStatus(CheckLimitsStatus),
    ParamDeltaStatus(CheckDeltaStatus),
    Unselected //0
};


struct ParamMonitoringConfiguration {
    PID : u16;
    type : MonitorCheckType;
    enabled : bool;
    definition : MonitorDefinition;
    repetition: u8;
    repetition_control: u8;
    interval : u8;
    interval_control : u8;
    transition_obt : TimeVal;
    temp_state : CheckState;
    current_state : CheckState;
};


struct ParamMonitoringTransition {
    PMONID : u16;
    PID : u16;
    type : MonitorCheckType;
    mask_value : u32;
	limit_value : u32;
	new_value : u32;
	prev_status : CheckState;
	new_status : CheckState;
	trans_obt : TimeVal;

};

struct RequestStatusUpdate {
    PMONID: u16;
    EvID: u16;
    current_monitor_definition: MonitorDefinition;
    fault_info: FaultInfo;
    new_status: CheckState;
    event_triggered: bool;
};

enum DoMonitoringReqStatus {
    Init,
    CheckPMONID,
    GetMonitoringType,
    DoLimitsMonitoring,
    DoExpectedValueMonitoring,
    GetRequestStatusUpdate,
    Exit
};

function get_check_status_index (status : CheckState) -> u8 {

    var index : u8 = 0;

    match status {

        case ParamValueStatus(param_status) => {

            match param_status {

                case MonitorUnchecked => {
                    index = 1;
                }
                case MonitorValueUnexpected => {
                    index = 2;
                }
                case MonitorValueExpected => {
                    index = 3;
                }
            }

        }
        case ParamLimitStatus(limit_status) => {

            match limit_status {

                case MonitorUnchecked => {
                    index = 4;
                }
                case MonitorAboveHighLimit => {
                    index = 5;
                }
                case MonitorBelowLowLimit => {
                    index = 6;
                }
                case MonitorWithinLimits => {
                    index = 7;
                }
            }

        }
        case ParamDeltaStatus(delta_status) => {

            match delta_status {

                case MonitorUnchecked => {
                    index = 8;
                }
                case MonitorDeltaLow => {
                    index = 9;
                }
                case MonitorDeltaHigh => {
                    index = 10;
                }
                case MonitorDeltaWithin => {
                    index = 11;
                }
            }

        }
        case Unselected => {

            index = 0;

        }
    }

    return index;
}

function get_type_index (type : MonitorCheckType) -> u8 {

    var index : u8 = 0;

    match type {

        case ExpectedValue => {
            index = 0;
        }
        case Limits => {
            index = 1;
        }
        case Delta => {
            index = 2;
        }
        case Free => {
            index = 0xFF;
        }
    }

    return index;
}


function are_status_equal (status1 : CheckState, status2 : CheckState) -> bool {

    var equal : bool = get_check_status_index(status1) == get_check_status_index(status2);

    return equal;
}




function set_unchecked (param_mon_config_table : &mut [ParamMonitoringConfiguration; max_num_pmon_ids], valid_PMONID : usize) {

    match (param_mon_config_table[valid_PMONID].current_state) {

        case ParamValueStatus(check_val) => {
            var monitor_unchecked : CheckValueStatus = CheckValueStatus::MonitorUnchecked;
            param_mon_config_table[valid_PMONID].current_state = CheckState::ParamValueStatus(monitor_unchecked);
        }
        case ParamLimitStatus(check_limits) => {
            var monitor_unchecked : CheckLimitsStatus = CheckLimitsStatus::MonitorUnchecked;
            param_mon_config_table[valid_PMONID].current_state = CheckState::ParamLimitStatus(monitor_unchecked);
        }
        case ParamDeltaStatus(check_delta) => {
            var monitor_unchecked : CheckDeltaStatus = CheckDeltaStatus::MonitorUnchecked;
            param_mon_config_table[valid_PMONID].current_state = CheckState::ParamDeltaStatus(monitor_unchecked);
        }
        case Unselected => {
            //Do nothing
        }
    }

    param_mon_config_table[valid_PMONID].temp_state = param_mon_config_table[valid_PMONID].current_state;

    return;
}


function get_check_type (aux : u8) -> MonitorCheckType {

    var monitor_check : MonitorCheckType = MonitorCheckType::Free;

    if (aux == 0) {

        monitor_check = MonitorCheckType::ExpectedValue;

    } else if (aux == 1) {

        monitor_check = MonitorCheckType::Limits;

    } else if (aux == 2) {

        monitor_check = MonitorCheckType::Delta;

    } else {

        monitor_check = MonitorCheckType::Free;

    }

    return monitor_check;
}

function get_PMON_limit_check_definition (tc_handler : &mut TCHandlerT, PID : u16, param_limit_check_definition : &mut MonitorDefinition) -> Result {

    var res : Result = Result::Ok;

    if (*param_limit_check_definition is MonitorDefinition::ParamLimitCheck) {

        var limits_def : ParamLimitCheckDefinition = {
            low_limit = 0,
            low_limit_evID = 0,
            high_limit = 0,
            high_limit_evID = 0
        };

        var type : DataPoolItemType = sys_data_pool_get_item_type(PID);

        match type {

            case u8_t => {

                var low_limit : u8 = 0;
                var high_limit : u8 = 0;

                //get low limit
                res = tc_handler_get_u8_appdata_field(tc_handler, &mut low_limit);

                //get low limit evID
                res = tc_handler_get_u16_appdata_field(tc_handler, &mut (limits_def.low_limit_evID));

                //get high limit
                res = tc_handler_get_u8_appdata_field(tc_handler, &mut high_limit);

                //get high limit evID
                res = tc_handler_get_u16_appdata_field(tc_handler, &mut (limits_def.high_limit_evID));

                limits_def.low_limit = low_limit as u32;
                limits_def.high_limit = high_limit as u32;

            }
            case u32_t => {

                //get low limit
                res = tc_handler_get_u32_appdata_field(tc_handler, &mut (limits_def.low_limit));
                
                //get low limit evID
                res = tc_handler_get_u16_appdata_field(tc_handler, &mut (limits_def.low_limit_evID));

                //get high limit
                res = tc_handler_get_u32_appdata_field(tc_handler, &mut (limits_def.low_limit));

                //get high limit evID
                res = tc_handler_get_u16_appdata_field(tc_handler, &mut (limits_def.high_limit_evID));

            }
            case NoValidPID => {
                res = Result::Error;
            }


        }

        *param_limit_check_definition = MonitorDefinition::ParamLimitCheck(limits_def);

    }
    else {
        //error
        res = Result::Error;
    }
  
    
    return res;

}


function get_PMON_value_check_definition (tc_handler : &mut TCHandlerT, PID : u16, expected_value_check_definition : &mut MonitorDefinition) -> Result {

    var res : Result = Result::Ok;

    if(*expected_value_check_definition is MonitorDefinition::ParamValueCheck) {

        var value_def : ParamValueCheckDefinition = {
            mask_value = 0,
            expected_value = 0,
            EvID = 0
        };

        var type : DataPoolItemType = sys_data_pool_get_item_type(PID);

        match type {

            case u8_t => {

                var mask : u8 = 0;
                var expected_value : u8 = 0;

                //get mask
                res = tc_handler_get_u8_appdata_field(tc_handler, &mut mask);

                //get expected value
                res = tc_handler_get_u8_appdata_field(tc_handler, &mut expected_value);

                //get EvID
                res = tc_handler_get_u16_appdata_field(tc_handler, &mut (value_def.EvID));

                value_def.mask_value = mask as u32;
                value_def.expected_value = expected_value as u32;

            }
            case u32_t => {

                //get mask
                res = tc_handler_get_u32_appdata_field(tc_handler, &mut (value_def.mask_value));

                //get expected value
                res = tc_handler_get_u32_appdata_field(tc_handler, &mut (value_def.expected_value));

                //get EvID
                res = tc_handler_get_u16_appdata_field(tc_handler, &mut (value_def.EvID));

            }
            case NoValidPID => {
                res = Result::Error;
            }

        }

        *expected_value_check_definition = MonitorDefinition::ParamValueCheck(value_def);
    }
    else {
        //error
        res = Result::Error;
    }

    
    return res;

}


function is_valid_check_limit_def (param_limit_check_definition : &MonitorDefinition) -> bool {

    var res : bool = false;

    match *param_limit_check_definition {

        case ParamLimitCheck(param_limit_def) => {

            if (param_limit_def.low_limit < param_limit_def.high_limit) {

                res = true;

            }
        }
        case ParamValueCheck(param_value_check_definition) => {

            res = false;

        }
        case ParamDeltaCheck(param_delta_check_definition) => {

            res = false;

        }
        case Unselected => {

            res = false;

        }
    }
    return res;
}

function add_valid_mng_mon_def (PMONID: usize, param_monit_config: &ParamMonitoringConfiguration,
                                 param_mon_config_table : &mut [ParamMonitoringConfiguration; max_num_pmon_ids]){

    (*param_mon_config_table)[PMONID] = *param_monit_config;

    (*param_mon_config_table)[PMONID].enabled = false;

    //set unckecked
    if (PMONID < max_num_pmon_ids){

        match (param_mon_config_table[PMONID].type) {

            case ExpectedValue => {

                var status : CheckValueStatus = CheckValueStatus::MonitorUnchecked;
                (*param_mon_config_table)[PMONID].current_state = CheckState::ParamValueStatus(status);
            }
            case Limits => {

                var status : CheckLimitsStatus = CheckLimitsStatus::MonitorUnchecked;
                (*param_mon_config_table)[PMONID].current_state = CheckState::ParamLimitStatus(status);

            }
            case Delta => { 

                var status : CheckDeltaStatus = CheckDeltaStatus::MonitorUnchecked;
                (*param_mon_config_table)[PMONID].current_state = CheckState::ParamDeltaStatus(status);

            }
            case Free => {

                //Error

            }    
 
        }

    }

    return;
}
