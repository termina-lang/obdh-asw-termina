/*
PUS SERVICE 5 : EVENT REPORTING
*/


import service_libraries.pus_services.pus_service5.pus_service5_help;



interface PUSS5Iface {

    procedure build_event_list_tms(&mut self, event_list : &mut EventList, result : &mut Result);
    procedure exec5_5TC(&mut self, tc_handler: &TCHandlerT, result: &mut Result);
    procedure exec5_6TC(&mut self, tc_handler: &TCHandlerT, result: &mut Result);
    procedure is_RID_enabled_ext(&mut self, RID: u16, p_enabled: &mut bool);

};

resource class PUSService5 provides PUSS5Iface {

    RID_enable_config : [u32; 4];

    tm_channel : access TMChannelIface;
    a_tm_descriptor_pool : access Allocator<TMDescriptorT>;
    tm_counter : access TMCounterIface;

    viewer is_RID_enabled(&self, RID : u16) -> bool {

        var enabled : bool = false;
        var index : usize = get_RID_enable_config_index(RID);
        var offset : u8 = get_RID_enable_config_offset(RID);

        if (index < 4){

            if(((self->RID_enable_config[index] >> offset) & 0x01) != 0){
                enabled = true;
            }
        }

        return enabled;
    }

    procedure is_RID_enabled_ext(&mut self, RID: u16, p_enabled: &mut bool) {

        *p_enabled = (self->is_RID_enabled(RID));

        return;
    }


    procedure build_event_list_tms(&mut self, event_list : &mut EventList, result : &mut Result) {

        for i : usize in 0 .. max_num_events while (i < event_list->num_events) {

            var event_info : EventInfo = {ev_RID = 0, ev_aux_data = [0; event_aux_data_max_size], ev_aux_data_size = 0};

            get_event_info(&(*event_list), i, &mut event_info);
 
            if(self->is_RID_enabled(event_info.ev_RID)){

                var index : usize = get_RID_enable_config_index(event_info.ev_RID);

                if (index < 4){

                    var tm_descriptor : Option<box TMDescriptorT> = None;
                    self->a_tm_descriptor_pool.alloc(&mut tm_descriptor);

                    match tm_descriptor {

                        case Some(descriptor) => {

                            var tm_count : u16 = 0 : u16;
                            self->tm_counter.get_next_tm_count(&mut tm_count);

                            build_tm_5_x(&mut descriptor, tm_count, &event_info, index);
                            self->tm_channel.send_tm(descriptor, result);
                        }
                        case None => {
                            *result = Result::Error;
                        }
                    }

                }
            }
                
        }

      return; 

    }


    procedure exec5_5TC(&mut self, tc_handler: &TCHandlerT, result: &mut Result) {

        var tm_descriptor : Option<box TMDescriptorT> = None;
        self->a_tm_descriptor_pool.alloc(&mut tm_descriptor);

        match tm_descriptor {

            case Some(descriptor) => {

                var tm_count : u16 = 0 : u16;
                self->tm_counter.get_next_tm_count(&mut tm_count);

                var N : u8 = 0;
                var RID : u16 = 0;
                *result = tc_handler_get_u8_appdata_field(tc_handler, &mut N);
                *result = tc_handler_get_u16_appdata_field(tc_handler, &mut RID);
                var index: usize = get_RID_enable_config_index(RID);
                var offset : u8 = get_RID_enable_config_offset(RID);

                if (result is Result::Error){

                    build_tm_1_4_short_pack_length(&mut descriptor, tm_count, tc_handler);
                } 
                else {

                    if (N != 1) {

                      build_tm_1_4_num_of_instr_not_valid(&mut descriptor, tm_count, tc_handler, N);
                    }
                    else {

                        var is_valid_EvID : bool = index < 4;

                        if(is_valid_EvID) {

                            build_tm_1_3(&mut descriptor, tm_count, tc_handler);

                            self->RID_enable_config[index] = self->RID_enable_config[index] | (1 << offset);

                            var tm_descriptor2 : Option<box TMDescriptorT> = None;
                            self->a_tm_descriptor_pool.alloc(&mut tm_descriptor2);

                            match tm_descriptor2 {

                                case Some(descriptor2) => {

                                    var tm_count2 : u16 = 0 : u16;
                                    self->tm_counter.get_next_tm_count(&mut tm_count2);

                                    build_tm_1_7(&mut descriptor2, tm_count2, tc_handler);
                                }
                                case None => {
                                    *result = Result::Error;
                                }
                            }

                        } else {

                            build_tm_1_4_EvID_not_valid(&mut descriptor, tm_count, tc_handler, RID);

                        }

                        self->tm_channel.send_tm(descriptor, result);

                        if (is_valid_EvID) {
                            self->tm_channel.send_tm(descriptor2, result);
                        }
                    }
                }
            }
            case None => {
                *result = Result::Error;
            }
        }

        return;
    }


    procedure exec5_6TC(&mut self, tc_handler: &TCHandlerT, result: &mut Result) {

        var tm_descriptor : Option<box TMDescriptorT> = None;
        self->a_tm_descriptor_pool.alloc(&mut tm_descriptor);

        match tm_descriptor {

            case Some(descriptor) => {

                var tm_count : u16 = 0 : u16;
                self->tm_counter.get_next_tm_count(&mut tm_count);

                var N : u8 = 0;
                var RID : u16 = 0;
                *result = tc_handler_get_u8_appdata_field(tc_handler, &mut N);
                *result = tc_handler_get_u16_appdata_field(tc_handler, &mut RID);
                var index: usize = get_RID_enable_config_index(RID);
                var offset : u8 = get_RID_enable_config_offset(RID);

                if (result is Result::Error){

                    build_tm_1_4_short_pack_length(&mut descriptor, tm_count, tc_handler);
                } 
                else {

                    if (N != 1) {

                      build_tm_1_4_num_of_instr_not_valid(&mut descriptor, tm_count, tc_handler, N);
                    }
                    else {

                        var is_valid_EvID : bool = index < 4;

                        if(is_valid_EvID) {

                            build_tm_1_3(&mut descriptor, tm_count, tc_handler);

                            self->RID_enable_config[index] = self->RID_enable_config[index] & (0xFFFFFFFE << offset);

                            var tm_descriptor2 : Option<box TMDescriptorT> = None;
                            self->a_tm_descriptor_pool.alloc(&mut tm_descriptor2);

                            match tm_descriptor2 {

                                case Some(descriptor2) => {

                                    var tm_count2 : u16 = 0 : u16;
                                    self->tm_counter.get_next_tm_count(&mut tm_count2);

                                    build_tm_1_7(&mut descriptor2, tm_count2, tc_handler);
                                }
                                case None => {
                                    *result = Result::Error;
                                }
                            }

                        } else {

                            build_tm_1_4_EvID_not_valid(&mut descriptor, tm_count, tc_handler, RID);

                        }

                        self->tm_channel.send_tm(descriptor, result);

                        if (is_valid_EvID) {
                            self->tm_channel.send_tm(descriptor2, result);
                        }
                    }
                }
            }
            case None => {
                *result = Result::Error;
            }
        }

        return;
    }
  
};



