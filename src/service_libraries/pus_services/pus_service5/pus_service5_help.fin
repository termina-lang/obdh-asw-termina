import service_libraries.tc_ccsds_pus_format;
import service_libraries.tm_ccsds_pus_format;
import service_libraries.serialize;
import service_libraries.pus_services.pus_service1.pus_service1;
import service_libraries.event_list;

const informative_Ev_IDs : u16 = 3;
const low_severity_anomaly_Ev_IDs : u16 = 4;
const medium_severity_anomaly_Ev_IDs : u16 = 0;
const high_severity_anomaly_Ev_IDs : u16 = 16;

const offset_mask : u16 = 0x001F; //Maximum Ev_IDs of each type in the baseline configuration is 32,
	                              //from 0xX000 to 0xX01F, where X is the Ev_ID type

enum Ev_IDType {
    Informative, //0x1XXX
    LowSeverityAnomaly, //0x2XXX
    MediumSeverityAnomaly, //0x3XXX
    HighSeverityAnomaly, //0x4XXX
    Ev_IDNotValid
};

struct ParamOutOfLimitInfo {
    PID : u16;
    PID_value : u32;
    PID_limit : u32;
};

struct ParamFaultValueInfo {
    PID : u16;
    PID_value : u32;
    PID_mask : u32;
    PID_expected_value : u32;
};

enum FaultInfo {
    ParamOutOfLimit(ParamOutOfLimitInfo),
    ParamFaultValue(ParamFaultValueInfo)
};



function get_Ev_ID_type(Ev_ID : u16) -> Ev_IDType {

    var Ev_ID_type: Ev_IDType = Ev_IDType::Ev_IDNotValid;
    var aux_type : u16 = Ev_ID >> 12 : u16;
    var aux_id : u16 = Ev_ID & 0x0FFF;

    if (aux_type == 1){
        if (aux_id < informative_Ev_IDs){
            Ev_ID_type = Ev_IDType::Informative;
        } else {
            Ev_ID_type = Ev_IDType::Ev_IDNotValid;
        }
    } else if (aux_type == 2){
        if (aux_id < low_severity_anomaly_Ev_IDs){
            Ev_ID_type = Ev_IDType::LowSeverityAnomaly;
        } else {
            Ev_ID_type = Ev_IDType::Ev_IDNotValid;
        }
    } else if (aux_type == 3){
        if (aux_id < medium_severity_anomaly_Ev_IDs){
            Ev_ID_type = Ev_IDType::MediumSeverityAnomaly;
        } else {
            Ev_ID_type = Ev_IDType::Ev_IDNotValid;
        }
    } else if (aux_type == 4){
        if (aux_id < high_severity_anomaly_Ev_IDs){
         Ev_ID_type = Ev_IDType::HighSeverityAnomaly;
        } else {
            Ev_ID_type = Ev_IDType::Ev_IDNotValid;
        }
    } else {
        Ev_ID_type = Ev_IDType::Ev_IDNotValid;
    }

    return Ev_ID_type;

}

function is_Ev_ID_valid (evID : u16) -> bool {

    var is_valid : bool = true;
    var evID_type : Ev_IDType = get_Ev_ID_type(evID);
    if (evID_type is Ev_IDType::Ev_IDNotValid){
        is_valid = false;
    } else {
        
    }
    return is_valid;
}



function get_Ev_ID_enable_config_index(Ev_ID : u16) -> usize {

    var Ev_ID_type : Ev_IDType = get_Ev_ID_type(Ev_ID);
    var index : usize = 4; //not valid index
    match Ev_ID_type {
        case Informative => {
            index = 0;
        }
        case LowSeverityAnomaly => {
            index = 1;
        }
        case MediumSeverityAnomaly => {
            index = 2;
        }
        case HighSeverityAnomaly => {
            index = 3;
        }
        case Ev_IDNotValid => {
            index = 4;
        }
    }

    return index;
}

function get_Ev_ID_enable_config_offset(Ev_ID : u16) -> u8 {

    return (Ev_ID & offset_mask) as u8;
} 

/*
function build_tm_5_x(p_tm_handler : &mut TMHandlerT,tm_seq_counter: u16, event : &EventInfo, index : usize){

    var tm_packet_header : CCSDSPUSTMPacketHeaderT =
	                                     {packet_id = 0 : u16,
	                                      packet_seq_ctrl = 0 : u16,
	                                      packet_length = 0 : u16};
	var df_header : CCSDSPUSTMDFHeaderT =
									{version = 0 : u8,
	 								type = 0 : u8,
	 								subtype = 0 : u8,
	 								destinationID = 0};

	tm_packet_header.packet_id = ccsds_pus_tm_build_packet_id(0x32C : u16);

	tm_packet_header.packet_seq_ctrl = ccsds_pus_tm_build_packet_seq_ctrl(0x3 : u16, tm_seq_counter);
	

	tm_packet_header.packet_length = 5 + event->ev_aux_data_size as u16;

	df_header.version = ccsds_pus_tm_build_df_header_version(0x1 : u8);
	df_header.type = 5 : u8;
	df_header.subtype = (index + 1) as u8;
	df_header.destinationID = 0x78 : u8;


	ccsds_pus_tm_set_fields(&mut p_tm_descriptor->tm_bytes[0 : usize .. 10 : usize], &tm_packet_header, &df_header);

	serialize_uint16(event->ev_Ev_ID, &mut p_tm_descriptor->tm_bytes[14 : usize .. 16 : usize]);

	for i : usize in 0 .. event_aux_data_max_size while (i < event->ev_aux_data_size) {

        p_tm_descriptor->tm_bytes[16 + i] = event->ev_aux_data[i];
    }
	
	// Calculate p_tm_descriptor->tm_num_bytes
	p_tm_descriptor->tm_num_bytes = tm_packet_header.packet_length as usize + 7;

    return;
}*/

