import service_libraries.tc_ccsds_pus_format;
import service_libraries.tm_ccsds_pus_format;
import service_libraries.serialize;
import service_libraries.pus_services.pus_service1.pus_service1;
import service_libraries.event_list;

const informative_RIDs : u16 = 3;
const low_severity_anomaly_RIDs : u16 = 4;
const medium_severity_anomaly_RIDs : u16 = 0;
const high_severity_anomaly_RIDs : u16 = 16;

const offset_mask : u16 = 0x001F; //Maximum RIDs of each type in the baseline configuration is 32,
	                              //from 0xX000 to 0xX01F, where X is the RID type

enum RIDType {
    Informative, //0x1XXX
    LowSeverityAnomaly, //0x2XXX
    MediumSeverityAnomaly, //0x3XXX
    HighSeverityAnomaly, //0x4XXX
    RIDNotValid
};



function get_RID_type(RID : u16) -> RIDType {

    var RID_type: RIDType = RIDType::RIDNotValid;
    var aux_type : u16 = RID >> 12 : u16;
    var aux_id : u16 = RID & 0x0FFF;

    if (aux_type == 1){
        if (aux_id < informative_RIDs){
            RID_type = RIDType::Informative;
        } else {
            RID_type = RIDType::RIDNotValid;
        }
    } else if (aux_type == 2){
        if (aux_id < low_severity_anomaly_RIDs){
            RID_type = RIDType::LowSeverityAnomaly;
        } else {
            RID_type = RIDType::RIDNotValid;
        }
    } else if (aux_type == 3){
        if (aux_id < medium_severity_anomaly_RIDs){
            RID_type = RIDType::MediumSeverityAnomaly;
        } else {
            RID_type = RIDType::RIDNotValid;
        }
    } else if (aux_type == 4){
        if (aux_id < high_severity_anomaly_RIDs){
         RID_type = RIDType::HighSeverityAnomaly;
        } else {
            RID_type = RIDType::RIDNotValid;
        }
    } else {
        RID_type = RIDType::RIDNotValid;
    }

    return RID_type;

}

function get_RID_enable_config_index(RID : u16) -> usize {

    var RID_type : RIDType = get_RID_type(RID);
    var index : usize = 4; //not valid index
    match RID_type {
        case Informative => {
            index = 0;
        }
        case LowSeverityAnomaly => {
            index = 1;
        }
        case MediumSeverityAnomaly => {
            index = 2;
        }
        case HighSeverityAnomaly => {
            index = 3;
        }
        case RIDNotValid => {
            index = 4;
        }
    }

    return index;
}

function get_RID_enable_config_offset(RID : u16) -> u8 {

    return (RID & offset_mask) as u8;
} 


function build_tm_5_x(p_tm_descriptor : &mut TMDescriptorT, tm_seq_counter: u16, event : &EventInfo, index : usize){

    var tm_packet_header : CCSDSPUSTMPacketHeaderT =
	                                     {packet_id = 0 : u16,
	                                      packet_seq_ctrl = 0 : u16,
	                                      packet_length = 0 : u16};
	var df_header : CCSDSPUSTMDFHeaderT =
									{version = 0 : u8,
	 								type = 0 : u8,
	 								subtype = 0 : u8,
	 								destinationID = 0 : u8};

	tm_packet_header.packet_id = ccsds_pus_tm_build_packet_id(0x32C : u16);

	tm_packet_header.packet_seq_ctrl = ccsds_pus_tm_build_packet_seq_ctrl(0x3 : u16, tm_seq_counter);
	

	tm_packet_header.packet_length = 5 + event->ev_aux_data_size as u16;

	df_header.version = ccsds_pus_tm_build_df_header_version(0x1 : u8);
	df_header.type = 5 : u8;
	df_header.subtype = (index + 1) as u8;
	df_header.destinationID = 0x78 : u8;


	ccsds_pus_tm_set_fields(&mut p_tm_descriptor->tm_bytes[0 : usize .. 10 : usize], &tm_packet_header, &df_header);

	serialize_uint16(event->ev_RID, &mut p_tm_descriptor->tm_bytes[14 : usize .. 16 : usize]);

	for i : usize in 0 .. event_aux_data_max_size while (i < event->ev_aux_data_size) {

        p_tm_descriptor->tm_bytes[16 + i] = event->ev_aux_data[i];
    }
	
	// Calculate p_tm_descriptor->tm_num_bytes
	p_tm_descriptor->tm_num_bytes = tm_packet_header.packet_length as usize + 7;

    return;
}