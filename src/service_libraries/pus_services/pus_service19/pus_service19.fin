/*
PUS SERVICE 19 : EVENT-ACTION
*/

import service_libraries.pus_services.pus_service19.pus_service19_help;

interface PUSS19Iface {

    procedure exec_tc (&mut self, tc_handler : &mut TCHandlerT, action_status: &mut Status<i32>);
    procedure manage_event_action(&mut self, evID: u16);
    procedure get_pending_action_number(&mut self, paction_num : &mut[usize;4]);
    procedure extract_action (&mut self, index : usize, action_packet : &mut TCHandlerT);
    
};

resource class PUSService19 provides PUSS19Iface {

    exec_tc_req_status : PSExecTCReqStatus;
    exec_tc_req_status_update : PS19ExecTCReqStatusUpdate;

    event_action_config : [EventActionConfig; max_event_action_definitions];
    event_action_packets : [TCHandlerT; max_event_action_definitions];
   
    pending_action_queue_1I : [TCHandlerT; event_action_queue_dimension];
    pending_action_queue_2LS : [TCHandlerT; event_action_queue_dimension];
    pending_action_queue_3MS : [TCHandlerT; event_action_queue_dimension];
    pending_action_queue_4HS : [TCHandlerT; event_action_queue_dimension];
    
    pending_action_number : [usize; 4];
    pending_action_head : [usize; 4];

    tm_channel: access TMChannelIface;   
    a_tm_handler_pool : access Allocator<TMHandlerT>;
    tm_counter : access TMCounterIface;

    pus_service_9 : access PUSS9Iface;

    method disable_event_action (&priv self) -> Status<i32> {

        var status : Status<i32> = Success;

        if(self->exec_tc_req_status_update.tc_data.EvID == self->event_action_config[self->exec_tc_req_status_update.ev_action_ID.ev_action_index].event_ID){

            self->event_action_config[self->exec_tc_req_status_update.ev_action_ID.ev_action_index].enabled = false;

        } else {

            status = Failure(EVENT_ACTION_NOT_DEFINED_ERROR);
        }

        return status;
    }


    method enable_event_action (&priv self) -> Status<i32> {

        var status : Status<i32> = Success;

        if(self->exec_tc_req_status_update.tc_data.EvID == self->event_action_config[self->exec_tc_req_status_update.ev_action_ID.ev_action_index].event_ID){

            self->event_action_config[self->exec_tc_req_status_update.ev_action_ID.ev_action_index].enabled = true;

        } else {

            status = Failure(EVENT_ACTION_NOT_DEFINED_ERROR);
        }

        return status;
    }

    method delete_event_action (&priv self) -> Status<i32> {

        var status : Status<i32> = Success;

        if(self->exec_tc_req_status_update.tc_data.EvID == self->event_action_config[self->exec_tc_req_status_update.ev_action_ID.ev_action_index].event_ID){

            self->event_action_config[self->exec_tc_req_status_update.ev_action_ID.ev_action_index].event_ID = 0;
            self->event_action_config[self->exec_tc_req_status_update.ev_action_ID.ev_action_index].enabled = false;
            

        } else {

            status = Failure(EVENT_ACTION_NOT_DEFINED_ERROR);
        }

        return status;
    }


    viewer get_event_action_config (&self, evID: u16, index: &mut usize, enabled: &mut bool) -> bool {

        var found: bool = false;

        for i : usize in 0 .. max_event_action_definitions while found == false {

            if (self->event_action_config[i].event_ID == evID) {

                    *index = i;
                    *enabled = self->event_action_config[i].enabled;
                    found = true;
            }
        }
        return found;
    }

    viewer get_free_event_action_index (&self)-> FoundID {

        var found_and_id: FoundID = {found = false, ev_action_index = 0};

        for i : usize in 0 .. max_event_action_definitions while found_and_id.found == false {

            if (self->event_action_config[i].event_ID == 0) {

                found_and_id.ev_action_index = i;
                found_and_id.found = true;
            }
        }
        return found_and_id;
    }


    viewer is_ev_action_defined (&self, enabled : &mut bool, evID : u16) -> FoundID {

        var found_and_id: FoundID = {found = false, ev_action_index = 0};

        for i : usize in 0 .. max_event_action_definitions while found_and_id.found == false {

            if (self->event_action_config[i].event_ID == evID) {

                found_and_id.ev_action_index = i;
                *enabled = self->event_action_config[i].enabled;
                found_and_id.found = true;
            }
        }
        return found_and_id;

    }


    //TC[19,1] allows the addition of event-action definitions
    method exec19_1TC (&priv self) -> PSExecTCReqStatus {

        var ack_enabled : bool = false;
        var next_status : PSExecTCReqStatus = {exec_tc_status = PSReqStatus::Exit, status = Success};

        var current_obt : MissionObt = {seconds = 0, finetime = 0};

        var tm_handler : Option<box TMHandlerT> = None;
        self->a_tm_handler_pool.alloc(&mut tm_handler);

        match tm_handler {

            case Some(b_tm_handler) => {

                var tm_count : u16 = 0 : u16;
                self->tm_counter.get_next_tm_count(&mut tm_count);

                if (self->exec_tc_req_status_update.tc_data.N != 1) {

                    self->pus_service_9.get_current_obt(&mut current_obt);
                    build_tm_1_4_num_of_instr_not_valid(&mut b_tm_handler, tm_count, (self->exec_tc_req_status_update.tc_data.packet_id), (self->exec_tc_req_status_update.tc_data.packet_error_ctrl),
                             self->exec_tc_req_status_update.tc_data.N, current_obt, &mut next_status.status);

                    if (next_status.status is Success){

                        self->tm_channel.send_tm(b_tm_handler, &mut next_status.status);

                    } 
                    else {
                        
                        self->a_tm_handler_pool.free(b_tm_handler);
                    }
                }
                else {

                    if (is_Ev_ID_valid(self->exec_tc_req_status_update.tc_data.EvID)) {

                        var is_enabled : bool = false;
                        var error: TC19_1_Error = TC19_1_Error::NoError;

                        self->exec_tc_req_status_update.ev_action_ID = self->is_ev_action_defined(&mut is_enabled, self->exec_tc_req_status_update.tc_data.EvID);

                        if (self->exec_tc_req_status_update.ev_action_ID.found){

                            if (is_enabled){

                                error = TC19_1_Error::EvIDEnabled;
                            }
                            else {

                                error = TC19_1_Error::NoError;
                            }

                        } else {

                            self->exec_tc_req_status_update.ev_action_ID = self->get_free_event_action_index();

                            if(self->exec_tc_req_status_update.ev_action_ID.found){
                                error = TC19_1_Error::NoError;
                            }
                            else {
                                error = TC19_1_Error::MaxEventActionDefinitions;
                            }
                        }

                        match error {

                            case NoError => {

                                var action_tc_handler : TCHandlerT = tc_handler_init();

                                tc_handler_build_from_descriptor (&mut action_tc_handler, &(self->exec_tc_req_status_update.action_tc_packet));
                            
                                var tc_status : TCStatus = {
                                    acceptation_status = TCAcceptationStatus::Undefined,
                                    execution_status = TCExecutionCtrl::Undefined,
                                    error_code =  TCErrorType::Undefined
                                };

                                tc_status = try_tc_acceptation(&(self->exec_tc_req_status_update.action_tc_packet)); 

                                if (tc_status.acceptation_status is TCAcceptationStatus::Accepted){

                                    self->pus_service_9.get_current_obt(&mut current_obt);
                                    build_tm_1_3(&mut b_tm_handler, tm_count, self->exec_tc_req_status_update.tc_data.flags_ack, current_obt, &mut next_status.status, &mut ack_enabled);

                                    if (ack_enabled) {

                                        if (next_status.status is Success){

                                            self->tm_channel.send_tm(b_tm_handler, &mut next_status.status);

                                        }
                                        else {
                                            self->a_tm_handler_pool.free(b_tm_handler);
                                        }

                                    } else {
                                        
                                        self->a_tm_handler_pool.free(b_tm_handler);
                                    }
                                
                                    self->event_action_config[self->exec_tc_req_status_update.ev_action_ID.ev_action_index].event_ID = self->exec_tc_req_status_update.tc_data.EvID;
                                    self->event_action_config[self->exec_tc_req_status_update.ev_action_ID.ev_action_index].enabled = false;


                                    var tm_handler2 : Option<box TMHandlerT> = None;
                                    self->a_tm_handler_pool.alloc(&mut tm_handler2);

                                    match tm_handler2 {

                                        case Some(b_tm_handler2) => {

                                            var tm_count2 : u16 = 0 : u16;
                                            self->tm_counter.get_next_tm_count(&mut tm_count2);
                                            self->pus_service_9.get_current_obt(&mut current_obt);
                                            build_tm_1_7(&mut b_tm_handler2, tm_count2, self->exec_tc_req_status_update.tc_data.flags_ack, current_obt, &mut next_status.status, &mut ack_enabled);

                                            if (ack_enabled) {

                                                if (next_status.status is Success){

                                                    self->tm_channel.send_tm(b_tm_handler2, &mut next_status.status);

                                                }
                                                else {
                                                    self->a_tm_handler_pool.free(b_tm_handler2);
                                    
                                                }

                                            } else {

                                                self->a_tm_handler_pool.free(b_tm_handler2);
                                            }
                                        }
                                        case None => {
                                            next_status.status = Failure(TM_POOL_ALLOC_FAILURE);
                                        }
                                    }

                                } else {

                                    self->pus_service_9.get_current_obt(&mut current_obt);
                                    build_tm_1_4_ev_action_rejected (&mut b_tm_handler, tm_count, (self->exec_tc_req_status_update.tc_data.packet_id), (self->exec_tc_req_status_update.tc_data.packet_error_ctrl),
                                                 self->exec_tc_req_status_update.tc_data.EvID, current_obt, &mut next_status.status);
                                    
                                    if (next_status.status is Success){

                                        self->tm_channel.send_tm(b_tm_handler, &mut next_status.status);

                                    } 
                                    else {
                                       
                                        self->a_tm_handler_pool.free(b_tm_handler);
            
                                    }
                                         
                                } 

                            }
                            case EvIDEnabled => {

                                self->pus_service_9.get_current_obt(&mut current_obt);
                                build_tm_1_4_ev_action_enabled(&mut b_tm_handler, tm_count, (self->exec_tc_req_status_update.tc_data.packet_id), (self->exec_tc_req_status_update.tc_data.packet_error_ctrl),
                                             self->exec_tc_req_status_update.tc_data.EvID, current_obt, &mut next_status.status);

                                if (next_status.status is Success){

                                    self->tm_channel.send_tm(b_tm_handler, &mut next_status.status);

                                } 
                                else {
                                   
                                    self->a_tm_handler_pool.free(b_tm_handler);

                                }
                                
                            }
                            case MaxEventActionDefinitions => {

                                self->pus_service_9.get_current_obt(&mut current_obt);
                                build_tm_1_8_max_ev_actions_defined(&mut b_tm_handler, tm_count, (self->exec_tc_req_status_update.tc_data.packet_id), (self->exec_tc_req_status_update.tc_data.packet_error_ctrl),
                                         self->exec_tc_req_status_update.tc_data.EvID, current_obt, &mut next_status.status);

                                if (next_status.status is Success){

                                    self->tm_channel.send_tm(b_tm_handler, &mut next_status.status);

                                } 
                                else {
                                   
                                    self->a_tm_handler_pool.free(b_tm_handler);
                            
                                }

                            }
                        }
                   
                    } else {

                        self->pus_service_9.get_current_obt(&mut current_obt);
                        build_tm_1_4_EvID_not_valid(&mut b_tm_handler, tm_count, (self->exec_tc_req_status_update.tc_data.packet_id), (self->exec_tc_req_status_update.tc_data.packet_error_ctrl),
                                     self->exec_tc_req_status_update.tc_data.EvID, current_obt, &mut next_status.status);

                        if (next_status.status is Success){

                            self->tm_channel.send_tm(b_tm_handler, &mut next_status.status);

                        } 
                        else {
                            
                            self->a_tm_handler_pool.free(b_tm_handler);
            
                        }

                    }
                }  
            }
         
            case None => {
                next_status.status = Failure(TM_POOL_ALLOC_FAILURE);
            }
        }

        return next_status;
    }


//TC[19,2] allows the deletion of event-action definitions
    method exec19_2TC (&priv self) -> PSExecTCReqStatus {

        var ack_enabled : bool = false;
        var next_status : PSExecTCReqStatus = {exec_tc_status = PSReqStatus::Exit, status = Success};

        var current_obt : MissionObt = {seconds = 0, finetime = 0};

        var tm_handler : Option<box TMHandlerT> = None;
        self->a_tm_handler_pool.alloc(&mut tm_handler);

        match tm_handler {

            case Some(b_tm_handler) => {

                var tm_count : u16 = 0 : u16;
                self->tm_counter.get_next_tm_count(&mut tm_count);

                if (self->exec_tc_req_status_update.tc_data.N != 1) {

                    self->pus_service_9.get_current_obt(&mut current_obt);
                    build_tm_1_4_num_of_instr_not_valid(&mut b_tm_handler, tm_count, (self->exec_tc_req_status_update.tc_data.packet_id), (self->exec_tc_req_status_update.tc_data.packet_error_ctrl),
                                 self->exec_tc_req_status_update.tc_data.N, current_obt, &mut next_status.status);
                        
                    if (next_status.status is Success){

                        self->tm_channel.send_tm(b_tm_handler, &mut next_status.status);

                    } 
                    else {
                        self->a_tm_handler_pool.free(b_tm_handler);
                    }   
                }
                else {

                    if (is_Ev_ID_valid(self->exec_tc_req_status_update.tc_data.EvID)) {

                        var is_enabled : bool = false;

                        self->exec_tc_req_status_update.ev_action_ID = self->is_ev_action_defined(&mut is_enabled, self->exec_tc_req_status_update.tc_data.EvID);

                        if (self->exec_tc_req_status_update.ev_action_ID.found){

                            if (is_enabled){

                                self->pus_service_9.get_current_obt(&mut current_obt);
                                build_tm_1_4_ev_action_enabled(&mut b_tm_handler, tm_count, (self->exec_tc_req_status_update.tc_data.packet_id), (self->exec_tc_req_status_update.tc_data.packet_error_ctrl),
                                             self->exec_tc_req_status_update.tc_data.EvID, current_obt, &mut next_status.status);

                                if (next_status.status is Success){

                                    self->tm_channel.send_tm(b_tm_handler, &mut next_status.status);

                                } 
                                else {
                                    self->a_tm_handler_pool.free(b_tm_handler);
                                }
            
                            } else {

                                self->pus_service_9.get_current_obt(&mut current_obt);
                                build_tm_1_3(&mut b_tm_handler, tm_count, self->exec_tc_req_status_update.tc_data.flags_ack, current_obt, &mut next_status.status, &mut ack_enabled);

                                if (ack_enabled) {

                                    if (next_status.status is Success){

                                        self->tm_channel.send_tm(b_tm_handler, &mut next_status.status);

                                    }
                                    else {
                                        self->a_tm_handler_pool.free(b_tm_handler);
                                    }

                                } else {
                                    
                                    self->a_tm_handler_pool.free(b_tm_handler);
                                }

                                next_status.status = self->delete_event_action();

                                if(next_status.status is Success){

                                    var tm_handler2 : Option<box TMHandlerT> = None;
                                    self->a_tm_handler_pool.alloc(&mut tm_handler2);

                                    match tm_handler2 {

                                        case Some(b_tm_handler2) => {

                                            var tm_count2 : u16 = 0 : u16;
                                            self->tm_counter.get_next_tm_count(&mut tm_count2);
                                            self->pus_service_9.get_current_obt(&mut current_obt);
                                            build_tm_1_7(&mut b_tm_handler2, tm_count2, self->exec_tc_req_status_update.tc_data.flags_ack, current_obt, &mut next_status.status, &mut ack_enabled);

                                            if (ack_enabled) {

                                                if (next_status.status is Success){

                                                    self->tm_channel.send_tm(b_tm_handler2, &mut next_status.status);
                                                }
                                                else {
                                                    self->a_tm_handler_pool.free(b_tm_handler2);
                                                   
                                                }

                                            } else {
                                                
                                                self->a_tm_handler_pool.free(b_tm_handler2);
                                            }
                                            
                                        }
                                        case None => {
                                            next_status.status = Failure(TM_POOL_ALLOC_FAILURE);
                                        }
                                    }

                                }

                            }

                        } else {

                            self->pus_service_9.get_current_obt(&mut current_obt);
                            build_tm_1_4_ev_action_undefined(&mut b_tm_handler, tm_count, (self->exec_tc_req_status_update.tc_data.packet_id), (self->exec_tc_req_status_update.tc_data.packet_error_ctrl),
                                         self->exec_tc_req_status_update.tc_data.EvID, current_obt, &mut next_status.status);

                            if (next_status.status is Success){

                                self->tm_channel.send_tm(b_tm_handler, &mut next_status.status);

                            } 
                            else {
                                self->a_tm_handler_pool.free(b_tm_handler);
            
                            }  
                        }
                    } else {
                        
                        self->pus_service_9.get_current_obt(&mut current_obt);
                        build_tm_1_4_EvID_not_valid(&mut b_tm_handler, tm_count, (self->exec_tc_req_status_update.tc_data.packet_id), (self->exec_tc_req_status_update.tc_data.packet_error_ctrl),
                                         self->exec_tc_req_status_update.tc_data.EvID, current_obt, &mut next_status.status);

                        if (next_status.status is Success){

                            self->tm_channel.send_tm(b_tm_handler, &mut next_status.status);

                        } 
                        else {
                            self->a_tm_handler_pool.free(b_tm_handler);
                            
                        }
                    }
                }
                
            }
            case None => {
                next_status.status = Failure(TM_POOL_ALLOC_FAILURE);
            }
        } 

        return next_status;
    }


    //TC[19,4] allows enabling event-action definitions
    method exec19_4TC (&priv self) -> PSExecTCReqStatus {

        var ack_enabled : bool = false;
        var next_status : PSExecTCReqStatus = {exec_tc_status = PSReqStatus::Exit, status = Success};

        var current_obt : MissionObt = {seconds = 0, finetime = 0};

        var tm_handler : Option<box TMHandlerT> = None;
        self->a_tm_handler_pool.alloc(&mut tm_handler);

        match tm_handler {

            case Some(b_tm_handler) => {

                var tm_count : u16 = 0 : u16;
                self->tm_counter.get_next_tm_count(&mut tm_count);

                if (self->exec_tc_req_status_update.tc_data.N != 1) {

                    self->pus_service_9.get_current_obt(&mut current_obt);
                    build_tm_1_4_num_of_instr_not_valid(&mut b_tm_handler, tm_count, (self->exec_tc_req_status_update.tc_data.packet_id), (self->exec_tc_req_status_update.tc_data.packet_error_ctrl),
                                 self->exec_tc_req_status_update.tc_data.N, current_obt, &mut next_status.status);

                    if (next_status.status is Success){

                        self->tm_channel.send_tm(b_tm_handler, &mut next_status.status);

                    } 
                    else {
                        self->a_tm_handler_pool.free(b_tm_handler);
                    }
                    
                }
                else {

                    if (is_Ev_ID_valid(self->exec_tc_req_status_update.tc_data.EvID)) {

                        var is_enabled : bool = false;

                        self->exec_tc_req_status_update.ev_action_ID = self->is_ev_action_defined(&mut is_enabled, self->exec_tc_req_status_update.tc_data.EvID);

                        if (self->exec_tc_req_status_update.ev_action_ID.found){

                                self->pus_service_9.get_current_obt(&mut current_obt);
                                build_tm_1_3(&mut b_tm_handler, tm_count, self->exec_tc_req_status_update.tc_data.flags_ack, current_obt, &mut next_status.status, &mut ack_enabled);

                                if (ack_enabled) {

                                    if (next_status.status is Success){

                                        self->tm_channel.send_tm(b_tm_handler, &mut next_status.status);

                                    }
                                    else {
                                        self->a_tm_handler_pool.free(b_tm_handler);
                            
                                    }

                                } else {
                                    
                                    self->a_tm_handler_pool.free(b_tm_handler);
                                }

                                next_status.status = self->enable_event_action();

                                if (next_status.status is Success){

                                    var tm_handler2 : Option<box TMHandlerT> = None;
                                    self->a_tm_handler_pool.alloc(&mut tm_handler2);

                                    match tm_handler2 {

                                        case Some(b_tm_handler2) => {

                                            var tm_count2 : u16 = 0 : u16;
                                            self->tm_counter.get_next_tm_count(&mut tm_count2);
                                            self->pus_service_9.get_current_obt(&mut current_obt);
                                            build_tm_1_7(&mut b_tm_handler2, tm_count2, self->exec_tc_req_status_update.tc_data.flags_ack, current_obt, &mut next_status.status, &mut ack_enabled);

                                            if (ack_enabled) {

                                                if (next_status.status is Success){

                                                    self->tm_channel.send_tm(b_tm_handler2, &mut next_status.status);

                                                }
                                                else {
                                                    self->a_tm_handler_pool.free(b_tm_handler2);
                                            
                                                }

                                            } else {
                                                
                                                self->a_tm_handler_pool.free(b_tm_handler2);
                                            }
                    
                                        }
                                        case None => {
                                            next_status.status = Failure(TM_POOL_ALLOC_FAILURE);
                                        }
                                    }

                                }
                        } else {

                            self->pus_service_9.get_current_obt(&mut current_obt);
                            build_tm_1_4_ev_action_undefined(&mut b_tm_handler, tm_count, (self->exec_tc_req_status_update.tc_data.packet_id), (self->exec_tc_req_status_update.tc_data.packet_error_ctrl),
                                     self->exec_tc_req_status_update.tc_data.EvID, current_obt, &mut next_status.status);

                            if (next_status.status is Success){

                                self->tm_channel.send_tm(b_tm_handler, &mut next_status.status);
                            } 
                            else {
                                self->a_tm_handler_pool.free(b_tm_handler);
                        
                            }
                            
                        }
                    } else {
                        
                        self->pus_service_9.get_current_obt(&mut current_obt);
                        build_tm_1_4_EvID_not_valid(&mut b_tm_handler, tm_count, (self->exec_tc_req_status_update.tc_data.packet_id), (self->exec_tc_req_status_update.tc_data.packet_error_ctrl),
                                 self->exec_tc_req_status_update.tc_data.EvID, current_obt, &mut next_status.status);
                                        
                        if (next_status.status is Success){

                            self->tm_channel.send_tm(b_tm_handler, &mut next_status.status);

                        } 
                        else {
                            self->a_tm_handler_pool.free(b_tm_handler);
                        
                        }
                    }
                }
                
            }
            case None => {
                next_status.status = Failure(TM_POOL_ALLOC_FAILURE);
            }
        }

        return next_status;
    }

    //TC[19,5] allows disabling event-action definitions
    method exec19_5TC (&priv self) -> PSExecTCReqStatus {

        var ack_enabled : bool = false;
        var next_status : PSExecTCReqStatus = {exec_tc_status = PSReqStatus::Exit, status = Success};

        var current_obt : MissionObt = {seconds = 0, finetime = 0};

        var tm_handler : Option<box TMHandlerT> = None;
        self->a_tm_handler_pool.alloc(&mut tm_handler);

        match tm_handler {

            case Some(b_tm_handler) => {

                var tm_count : u16 = 0 : u16;
                self->tm_counter.get_next_tm_count(&mut tm_count);

                if (self->exec_tc_req_status_update.tc_data.N != 1) {

                    self->pus_service_9.get_current_obt(&mut current_obt);
                    build_tm_1_4_num_of_instr_not_valid(&mut b_tm_handler, tm_count, (self->exec_tc_req_status_update.tc_data.packet_id), (self->exec_tc_req_status_update.tc_data.packet_error_ctrl),
                                 self->exec_tc_req_status_update.tc_data.N, current_obt, &mut next_status.status);

                    if (next_status.status is Success){

                        self->tm_channel.send_tm(b_tm_handler, &mut next_status.status);

                    } 
                    else {
                        self->a_tm_handler_pool.free(b_tm_handler);
                     
                    }
                }
                else {

                    if (is_Ev_ID_valid(self->exec_tc_req_status_update.tc_data.EvID)) {

                        var is_enabled : bool = false;

                        self->exec_tc_req_status_update.ev_action_ID = self->is_ev_action_defined(&mut is_enabled, self->exec_tc_req_status_update.tc_data.EvID);

                        if (self->exec_tc_req_status_update.ev_action_ID.found){

                                self->pus_service_9.get_current_obt(&mut current_obt);
                                build_tm_1_3(&mut b_tm_handler, tm_count, self->exec_tc_req_status_update.tc_data.flags_ack, current_obt, &mut next_status.status, &mut ack_enabled);

                                if (ack_enabled) {

                                    if (next_status.status is Success){

                                        self->tm_channel.send_tm(b_tm_handler, &mut next_status.status);

                                    }
                                    else {
                                        self->a_tm_handler_pool.free(b_tm_handler);
                                    
                                    }

                                } else {
                                    
                                    self->a_tm_handler_pool.free(b_tm_handler);
                                }

                                next_status.status = self->disable_event_action();

                                if (next_status.status is Success){

                                    var tm_handler2 : Option<box TMHandlerT> = None;
                                    self->a_tm_handler_pool.alloc(&mut tm_handler2);

                                    match tm_handler2 {

                                        case Some(b_tm_handler2) => {

                                            var tm_count2 : u16 = 0 : u16;
                                            self->tm_counter.get_next_tm_count(&mut tm_count2);
                                            self->pus_service_9.get_current_obt(&mut current_obt);
                                            build_tm_1_7(&mut b_tm_handler2, tm_count2, self->exec_tc_req_status_update.tc_data.flags_ack, current_obt, &mut next_status.status, &mut ack_enabled);

                                            if (ack_enabled) {

                                                if (next_status.status is Success){

                                                    self->tm_channel.send_tm(b_tm_handler2, &mut next_status.status);

                                                }
                                                else {
                                                    self->a_tm_handler_pool.free(b_tm_handler2);
                                              
                                                }

                                            } else {
                                                
                                                self->a_tm_handler_pool.free(b_tm_handler2);
                                            }
                                            
                                        }
                                        case None => {
                                            next_status.status = Failure(TM_POOL_ALLOC_FAILURE);
                                        }
                                    }
                                }

                        } else {

                            self->pus_service_9.get_current_obt(&mut current_obt);
                            build_tm_1_4_ev_action_undefined(&mut b_tm_handler, tm_count, (self->exec_tc_req_status_update.tc_data.packet_id), (self->exec_tc_req_status_update.tc_data.packet_error_ctrl),
                                         self->exec_tc_req_status_update.tc_data.EvID, current_obt, &mut next_status.status);

                            if (next_status.status is Success){

                                self->tm_channel.send_tm(b_tm_handler, &mut next_status.status);

                            } 
                            else {
                                self->a_tm_handler_pool.free(b_tm_handler);
                            
                            }
                        }
                    } else {
                        
                        self->pus_service_9.get_current_obt(&mut current_obt);
                        build_tm_1_4_EvID_not_valid(&mut b_tm_handler, tm_count, (self->exec_tc_req_status_update.tc_data.packet_id), (self->exec_tc_req_status_update.tc_data.packet_error_ctrl),
                                 self->exec_tc_req_status_update.tc_data.EvID, current_obt, &mut next_status.status);

                        if (next_status.status is Success){

                            self->tm_channel.send_tm(b_tm_handler, &mut next_status.status);

                        } 
                        else {
                            self->a_tm_handler_pool.free(b_tm_handler);
                        
                        }
                    }
                    
                }
            }
            case None => {
                next_status.status = Failure(TM_POOL_ALLOC_FAILURE);
            }
        }

        return next_status;
    }

   

    viewer manage_short_pack_length_error(&self) -> PSExecTCReqStatus {

        var next_status : PSExecTCReqStatus = {exec_tc_status = PSReqStatus::Exit, status = Success};

        var current_obt : MissionObt = {seconds = 0, finetime = 0};

        var tm_handler : Option<box TMHandlerT> = None;
        self->a_tm_handler_pool.alloc(&mut tm_handler);

        match tm_handler {

            case Some(b_tm_handler) => {

                var tm_count : u16 = 0 : u16;
                self->tm_counter.get_next_tm_count(&mut tm_count);

                self->pus_service_9.get_current_obt(&mut current_obt);
                build_tm_1_4_short_pack_length(&mut b_tm_handler, tm_count, (self->exec_tc_req_status_update.tc_data.packet_id), (self->exec_tc_req_status_update.tc_data.packet_error_ctrl),
                             (self->exec_tc_req_status_update.tc_data.tc_num_bytes), current_obt, &mut next_status.status);

                if (next_status.status is Success){

                    self->tm_channel.send_tm(b_tm_handler, &mut next_status.status);

                } 
                else {
                    self->a_tm_handler_pool.free(b_tm_handler);

                }
            }
            case None => {
                next_status.status = Failure(TM_POOL_ALLOC_FAILURE);
            }
        }

        return next_status;
    }

    viewer manage_error_in_acceptance(&self) -> PSExecTCReqStatus {

        var next_status : PSExecTCReqStatus = {exec_tc_status = PSReqStatus::Exit, status = Success};

        var current_obt : MissionObt = {seconds = 0, finetime = 0};

        var tm_handler : Option<box TMHandlerT> = None;
        self->a_tm_handler_pool.alloc(&mut tm_handler);

        match tm_handler {

            case Some(b_tm_handler) => {

                var tm_count : u16 = 0 : u16;
                self->tm_counter.get_next_tm_count(&mut tm_count);

                self->pus_service_9.get_current_obt(&mut current_obt);
                build_tm_1_4_error_in_acceptance(&mut b_tm_handler, tm_count, (self->exec_tc_req_status_update.tc_data.packet_id), (self->exec_tc_req_status_update.tc_data.packet_error_ctrl),
                                 current_obt, &mut next_status.status);
                
                if (next_status.status is Success){

                    self->tm_channel.send_tm(b_tm_handler, &mut next_status.status);

                } 
                else {
                    self->a_tm_handler_pool.free(b_tm_handler);
                        
                }
                
            }
            case None => {
                next_status.status = Failure(TM_POOL_ALLOC_FAILURE);
            }
        }

        return next_status;
    }

    viewer manage_tm_limit_app_data_reached(&self) -> PSExecTCReqStatus {

        var next_status : PSExecTCReqStatus = {exec_tc_status = PSReqStatus::Exit, status = Success};

        var current_obt : MissionObt = {seconds = 0, finetime = 0};

        var tm_handler : Option<box TMHandlerT> = None;
        self->a_tm_handler_pool.alloc(&mut tm_handler);

        match tm_handler {

            case Some(b_tm_handler) => {

                var tm_count : u16 = 0 : u16;
                self->tm_counter.get_next_tm_count(&mut tm_count);

                self->pus_service_9.get_current_obt(&mut current_obt);
                build_tm_1_8_tm_exceed_limit_appdata(&mut b_tm_handler, tm_count, (self->exec_tc_req_status_update.tc_data.packet_id), (self->exec_tc_req_status_update.tc_data.packet_error_ctrl),
                                 current_obt, &mut next_status.status);
                
                if (next_status.status is Success){

                    self->tm_channel.send_tm(b_tm_handler, &mut next_status.status);

                } 
                else {
                    self->a_tm_handler_pool.free(b_tm_handler);
    
                }
                
            }
            case None => {
                next_status.status = Failure(TM_POOL_ALLOC_FAILURE);
            }
        }

        return next_status;
    }


    procedure exec_tc (&mut self, tc_handler : &mut TCHandlerT, action_status: &mut Status<i32>){

        var subtype : u8 = tc_handler->df_header.subtype;

        for i : usize in 0 .. 3 while (self->exec_tc_req_status.exec_tc_status is PSReqStatus::Exit == false) {

            match self->exec_tc_req_status.exec_tc_status {

                case Init => {

                    self->exec_tc_req_status_update.tc_data.packet_id = tc_handler->packet_header.packet_id;
                    self->exec_tc_req_status_update.tc_data.packet_error_ctrl = tc_handler->packet_error_ctrl;
                    self->exec_tc_req_status_update.tc_data.flags_ack = tc_handler->df_header.flag_ver_ack;
                    self->exec_tc_req_status_update.tc_data.tc_num_bytes = tc_handler->tc_descriptor.tc_num_bytes;
                    self->exec_tc_req_status.status = tc_handler_get_u8_appdata_field(tc_handler, &mut (self->exec_tc_req_status_update.tc_data.N));
                    self->exec_tc_req_status.status = tc_handler_get_u16_appdata_field(tc_handler, &mut (self->exec_tc_req_status_update.tc_data.EvID));

                    if (subtype == 1){

                        self->exec_tc_req_status_update.action_tc_packet.tc_num_bytes = tc_handler->tc_descriptor.tc_num_bytes - 2 - tc_handler->app_data_index;
                        
                        for j : usize in 0 .. event_action_max_bytes while j < (self->exec_tc_req_status_update.action_tc_packet.tc_num_bytes) {

                            self->exec_tc_req_status_update.action_tc_packet.tc_bytes[j] = tc_handler->tc_descriptor.tc_bytes[j + 12];

                        }

                    }

                    if (self->exec_tc_req_status.status is Success) {

                        self->exec_tc_req_status.exec_tc_status = PSReqStatus::ExecTC;
                        
                    } else {

                        self->exec_tc_req_status.exec_tc_status = PSReqStatus::Exit;
                        
                    }

                }
                case ExecTC => {

                    if (subtype == 1) {

                        self->exec_tc_req_status = self->exec19_1TC();

                    } else if (subtype == 2) {

                        self->exec_tc_req_status = self->exec19_2TC();

                    } else if (subtype == 4) {

                        self->exec_tc_req_status = self->exec19_4TC();

                    } else if (subtype == 5) {

                        self->exec_tc_req_status = self->exec19_5TC();

                    } else {

                        self->exec_tc_req_status.status = Failure(ACCEPTANCE_ERROR);
                        self->exec_tc_req_status.exec_tc_status = PSReqStatus::Exit;
                    }
                }
                case Exit => {
                    //Unreachable point
                }  
            }
        }

        match self->exec_tc_req_status.status {
                        
            case Success => {

                *action_status = Success;
    
            }
            case Failure(error_code) => {

                if (error_code == ACCEPTANCE_ERROR) {

                    self->exec_tc_req_status = self->manage_error_in_acceptance();
                    
                } else if (error_code == BUILD_TM_ERROR) {

                    self->exec_tc_req_status = self->manage_tm_limit_app_data_reached();
                
                } else if (error_code == TC_DATA_OUT_OF_RANGE_ERROR) {

                    self->exec_tc_req_status = self->manage_short_pack_length_error();

                } else if (error_code == EVENT_ACTION_NOT_DEFINED_ERROR) {

                    // TO DO: already managed error
                
                } else {
                    
                    *action_status = Failure(error_code);
                
                }
                
            }  
        }

        self->exec_tc_req_status = {
                    exec_tc_status = PSReqStatus::Init,
                    status = Success
                };

        
        return;
    
    }

    
    procedure manage_event_action(&mut self, evID: u16){

        var found_and_id: FoundID = {found = false, ev_action_index = 0};
        var is_enabled : bool = false;
        found_and_id = self->is_ev_action_defined(&mut is_enabled, evID);

        if(found_and_id.found && is_enabled){

            if(found_and_id.ev_action_index < max_event_action_definitions){

                var RID_type : Ev_IDType = get_Ev_ID_type(evID);
                var tail_index : usize = 0;
                   
                match RID_type {
                    case Informative => {
                        
                        if (self->pending_action_number[0] < event_action_queue_dimension){

                            tail_index = (self->pending_action_head[0] + self->pending_action_number[0])%event_action_queue_dimension;
                            self->pending_action_queue_1I[tail_index] = self->event_action_packets[found_and_id.ev_action_index];
                            self->pending_action_number[0] = self->pending_action_number[0] + 1;
                        }
                        else {
                            //error
                        }
                
                    
                    }
                    case LowSeverityAnomaly => {

                        if (self->pending_action_number[1] < event_action_queue_dimension){

                            tail_index = (self->pending_action_head[1] + self->pending_action_number[1])%event_action_queue_dimension;
                            self->pending_action_queue_2LS[tail_index] = self->event_action_packets[found_and_id.ev_action_index];
                            self->pending_action_number[1] = self->pending_action_number[1] + 1;
                        }
                        else {
                            //error
                        }

                        
                    }
                    case MediumSeverityAnomaly => {

                        if (self->pending_action_number[2] < event_action_queue_dimension){

                            tail_index = (self->pending_action_head[2] + self->pending_action_number[2])%event_action_queue_dimension;
                            self->pending_action_queue_3MS[tail_index] = self->event_action_packets[found_and_id.ev_action_index];
                            self->pending_action_number[2] = self->pending_action_number[2] +1;
                        }
                        else {
                            //error
                        }

                        
                    }
                    case HighSeverityAnomaly => {

                        if (self->pending_action_number[3] < event_action_queue_dimension){

                            tail_index = (self->pending_action_head[3] + self->pending_action_number[3])%event_action_queue_dimension;
                            self->pending_action_queue_4HS[tail_index] = self->event_action_packets[found_and_id.ev_action_index];
                            self->pending_action_number[3] = self->pending_action_number[3] +1;
                        }
                        else {
                            //error
                        }

                    
                    }
                    case Ev_IDNotValid => {

                        //error
                        
                    }
                }

                
            }
            else {

                //error
            }
        }

        return;
    }
        


    procedure get_pending_action_number(&mut self, paction_num : &mut[usize;4]){

        for i: usize in 0 .. 3 {

            paction_num[i] = self->pending_action_number[i];

        }

        return;
    }

    procedure extract_action (&mut self, index : usize, action_packet : &mut TCHandlerT){

        if (index == 0){

            *action_packet = self->pending_action_queue_1I[self->pending_action_head[0]];

        } else if (index == 1){

            *action_packet = self->pending_action_queue_2LS[self->pending_action_head[1]];

        } else if (index == 2){

            *action_packet = self->pending_action_queue_3MS[self->pending_action_head[2]];

        } else if (index == 3){

            *action_packet = self->pending_action_queue_4HS[self->pending_action_head[3]];

        } else {
            //error
        } 

        return;

    }

    


};








