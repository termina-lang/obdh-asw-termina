/*
PUS SERVICE 5 : EVENT REPORTING
*/

import service_libraries.tc_ccsds_pus_format;
import service_libraries.tm_ccsds_pus_format;
import service_libraries.serialize;
import service_libraries.pus_services.pus_service1;
import service_libraries.event_list;

const informative_RIDs : u16 = 3;
const low_severity_anomaly_RIDs : u16 = 4;
const medium_severity_anomaly_RIDs : u16 = 0;
const high_severity_anomaly_RIDs : u16 = 16;

const offset_mask : u16 = 0x001F; //Maximum RIDs of each type in the baseline configuration is 32,
	                              //from 0xX000 to 0xX01F, where X is the RID type


enum RIDType {
    Informative, //0x1XXX
    LowSeverityAnomaly, //0x2XXX
    MediumSeverityAnomaly, //0x3XXX
    HighSeverityAnomaly, //0x4XXX
    RIDNotValid
};


function get_RID_type(RID : u16) -> RIDType {

    var RID_type: RIDType = RIDType::RIDNotValid;
    var aux_type : u16 = RID >> 12 : u16;
    var aux_id : u16 = RID & 0x0FFF;

    if (aux_type == 1){
        if (aux_id < informative_RIDs){
            RID_type = RIDType::Informative;
        } else {
            RID_type = RIDType::RIDNotValid;
        }
    } else if (aux_type == 2){
        if (aux_id < low_severity_anomaly_RIDs){
            RID_type = RIDType::LowSeverityAnomaly;
        } else {
            RID_type = RIDType::RIDNotValid;
        }
    } else if (aux_type == 3){
        if (aux_id < medium_severity_anomaly_RIDs){
            RID_type = RIDType::MediumSeverityAnomaly;
        } else {
            RID_type = RIDType::RIDNotValid;
        }
    } else if (aux_type == 4){
        if (aux_id < high_severity_anomaly_RIDs){
         RID_type = RIDType::HighSeverityAnomaly;
        } else {
            RID_type = RIDType::RIDNotValid;
        }
    } else {
        RID_type = RIDType::RIDNotValid;
    }

    return RID_type;

}

function get_RID_enable_config_index(RID : u16) -> usize {

    var RID_type : RIDType = get_RID_type(RID);
    var index : usize = 4; //not valid index
    match RID_type {
        case Informative => {
            index = 0;
        }
        case LowSeverityAnomaly => {
            index = 1;
        }
        case MediumSeverityAnomaly => {
            index = 2;
        }
        case HighSeverityAnomaly => {
            index = 3;
        }
        case RIDNotValid => {
            index = 4;
        }
    }

    return index;
}

function is_RID_enabled(RID : u16, RID_enable_config_table : &[u32;4]) -> bool {

    var enabled : bool = false;
    var index : usize = get_RID_enable_config_index(RID);
    var offset : u8 = (RID & offset_mask) as u8;

    if (index < 4){

        if(((RID_enable_config_table[index] >> offset) & 0x01) != 0){
            enabled = true;
        }
    }

    return enabled;
}



function exec5_5TC(tc_descriptor: &TCDescriptorT, tm_descriptor: &mut TMDescriptorT, tm_seq_counter: u16, RID_enable_config_table: &mut [u32; 4]){

    var RID : u16 = deserialize_uint16(&(tc_descriptor->tc_bytes[10 : usize .. 12 : usize]));
    var index: usize = get_RID_enable_config_index(RID);
    var offset : u8 = (RID & offset_mask) as u8;

    if(index < 4) {

        RID_enable_config_table[index] = RID_enable_config_table[index] | (1 << offset);
        build_tm_1_7(tm_descriptor, tm_seq_counter, tc_descriptor);

    } else {

        build_tm_1_8_tc_5_X_RIDunknown(tm_descriptor, tm_seq_counter, RID, tc_descriptor);

    }

    return;
}


function exec5_6TC(tc_descriptor: &TCDescriptorT, tm_descriptor: &mut TMDescriptorT, tm_seq_counter: u16, RID_enable_config_table: &mut [u32; 4]){

    var RID : u16 = deserialize_uint16(&(tc_descriptor->tc_bytes[10 : usize .. 12 : usize]));
    var index: usize = get_RID_enable_config_index(RID);
    var offset : u8 = (RID & offset_mask) as u8;

    if(index < 4) {

        RID_enable_config_table[index] = RID_enable_config_table[index] & (0xFFFFFFFE << offset);
        build_tm_1_7(tm_descriptor, tm_seq_counter, tc_descriptor);

    } else {

        build_tm_1_8_tc_5_X_RIDunknown(tm_descriptor, tm_seq_counter, RID, tc_descriptor);

    }

    return;
}


function PUS_service_5_execTC (tc_descriptor : &TCDescriptorT, tm_descriptor : &mut TMDescriptorT, tm_seq_counter: u16, RID_enable_config_table : &mut [u32; 4]){

    var subtype : u8 = get_subtype(&(tc_descriptor->tc_bytes));
    
    if (subtype == 5){

        exec5_5TC(tc_descriptor, tm_descriptor, tm_seq_counter, RID_enable_config_table);
    } 
    else if (subtype == 6){

        exec5_6TC(tc_descriptor, tm_descriptor, tm_seq_counter, RID_enable_config_table);

    } else {

        //This is an error in acceptance, could be modeled as an event
        /* If the acceptance process is correct, this point should not be reached */
    }

    return;
}


function build_tm_5_x(p_tm_descriptor : &mut TMDescriptorT, tm_seq_counter: u16, event : &EventInfo, index : usize){

    var tm_packet_header : CCSDSPUSTMPacketHeaderT =
	                                     {packet_id = 0 : u16,
	                                      packet_seq_ctrl = 0 : u16,
	                                      packet_length = 0 : u16};
	var df_header : CCSDSPUSTMDFHeaderT =
									{version = 0 : u8,
	 								type = 0 : u8,
	 								subtype = 0 : u8,
	 								destinationID = 0 : u8};

	tm_packet_header.packet_id = ccsds_pus_tm_build_packet_id(0x32C : u16);

	tm_packet_header.packet_seq_ctrl = ccsds_pus_tm_build_packet_seq_ctrl(0x3 : u16, tm_seq_counter);
	

	tm_packet_header.packet_length = 5 + event->ev_aux_data_size as u16;

	df_header.version = ccsds_pus_tm_build_df_header_version(0x1 : u8);
	df_header.type = 5 : u8;
	df_header.subtype = (index + 1) as u8;
	df_header.destinationID = 0x78 : u8;


	ccsds_pus_tm_set_fields(&mut p_tm_descriptor->tm_bytes[0 : usize .. 10 : usize], &tm_packet_header, &df_header);

	serialize_uint16(event->ev_RID, &mut p_tm_descriptor->tm_bytes[14 : usize .. 16 : usize]);

	for i : usize in 0 .. event_aux_data_max_size while (i < event->ev_aux_data_size) {

        p_tm_descriptor->tm_bytes[16 + i] = event->ev_aux_data[i];
    }
	
	// Calculate p_tm_descriptor->tm_num_bytes
	p_tm_descriptor->tm_num_bytes = tm_packet_header.packet_length as usize + 7;

    return;
}
