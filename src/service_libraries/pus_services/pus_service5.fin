/*
PUS SERVICE 5 : EVENT REPORTING
*/

import service_libraries.tc_ccsds_pus_format;
import service_libraries.tm_ccsds_pus_format;
import service_libraries.serialize;
import service_libraries.pus_services.pus_service1;
import service_libraries.event_list;

const informative_RIDs : u16 = 3;
const low_severity_anomaly_RIDs : u16 = 4;
const medium_severity_anomaly_RIDs : u16 = 0;
const high_severity_anomaly_RIDs : u16 = 16;

const offset_mask : u16 = 0x001F; //Maximum RIDs of each type in the baseline configuration is 32,
	                              //from 0xX000 to 0xX01F, where X is the RID type

enum RIDType {
    Informative, //0x1XXX
    LowSeverityAnomaly, //0x2XXX
    MediumSeverityAnomaly, //0x3XXX
    HighSeverityAnomaly, //0x4XXX
    RIDNotValid
};

interface PUSS5Iface {

    procedure build_event_list_tms(&mut self, event_list : &mut EventList);
    procedure exec5_5TC(&mut self, tc_descriptor: &TCDescriptorT, tm_descriptor: &mut TMDescriptorT, tm_seq_counter: u16);
    procedure exec5_6TC(&mut self, tc_descriptor: &TCDescriptorT, tm_descriptor: &mut TMDescriptorT, tm_seq_counter: u16);
    procedure is_RID_enabled_ext(&mut self, RID: u16);

};

resource class PUSService5 provides PUSS5Iface {

    RID_enable_config : [u32; 4];

    tm_channel : access TMChannelIface;
    a_tm_descriptor_pool : access Allocator<TMDescriptorT>;
    tm_counter : access TMCounterIface;

    viewer is_RID_enabled(&self, RID : u16) -> bool {

        var enabled : bool = false;
        var index : usize = get_RID_enable_config_index(RID);
        var offset : u8 = get_RID_enable_config_offset(RID);

        if (index < 4){

            if(((self->RID_enable_config[index] >> offset) & 0x01) != 0){
                enabled = true;
            }
        }

        return enabled;
    }

    procedure is_RID_enabled_ext(&mut self, RID: u16) -> bool {

        return (self->is_RID_enabled(RID));
    }


    procedure build_event_list_tms(&mut self, event_list : &mut EventList){

        for i : usize in 0 .. max_num_events while (i < event_list->num_events) {

            var event_info : EventInfo = {ev_RID = 0, ev_aux_data = [0; event_aux_data_max_size], ev_aux_data_size = 0};

            get_event_info(&(*event_list), i, &mut event_info);
 
            if(self->is_RID_enabled(event_info.ev_RID, &(self->pus_serv5_RID_enable_config))){

                var index : usize = get_RID_enable_config_index(event_info.ev_RID);

                if (index < 4){

                    var tm_descriptor : Option<box TMDescriptorT> = None;
                    self->a_tm_descriptor_pool.alloc(&mut tm_descriptor);

                    match tm_descriptor {

                        case Some(descriptor) => {

                            var tm_count : u16 = 0 : u16;
                            self->tm_counter.get_next_tm_count(&mut tm_count);

                            build_tm_5_x(&mut descriptor, tm_count, &event_ino, index);
                            self->tm_channel.send_tm(descriptor);
                        }
                        case None => {
                            res = Result::Error;
                        }
                    }

                }
            }
                
        }

      return; 

    }


    procedure exec5_5TC(&mut self, tc_descriptor: &TCDescriptorT, tm_descriptor: &mut TMDescriptorT, tm_seq_counter: u16){

        var RID : u16 = deserialize_uint16(&(tc_descriptor->tc_bytes[10 : usize .. 12 : usize]));
        var index: usize = get_RID_enable_config_index(RID);
        var offset : u8 = get_RID_enable_config_offset(RID);

        if(index < 4) {

            self->RID_enable_config[index] = self->RID_enable_config[index] | (1 << offset);
            build_tm_1_7(tm_descriptor, tm_seq_counter, tc_descriptor);

        } else {

            build_tm_1_8_tc_5_X_RIDunknown(tm_descriptor, tm_seq_counter, RID, tc_descriptor);

        }

        return;
    }


    procedure exec5_6TC(&mut self, tc_descriptor: &TCDescriptorT, tm_descriptor: &mut TMDescriptorT, tm_seq_counter: u16){

        var RID : u16 = deserialize_uint16(&(tc_descriptor->tc_bytes[10 : usize .. 12 : usize]));
        var index: usize = get_RID_enable_config_index(RID);
        var offset : u8 = get_RID_enable_config_offset(RID);

        if(index < 4) {

            self->RID_enable_config[index] = self->RID_enable_config[index] & (0xFFFFFFFE << offset);
            build_tm_1_7(tm_descriptor, tm_seq_counter, tc_descriptor);

        } else {

            build_tm_1_8_tc_5_X_RIDunknown(tm_descriptor, tm_seq_counter, RID, tc_descriptor);

        }

        return;
    }

  
};


function get_RID_type(RID : u16) -> RIDType {

    var RID_type: RIDType = RIDType::RIDNotValid;
    var aux_type : u16 = RID >> 12 : u16;
    var aux_id : u16 = RID & 0x0FFF;

    if (aux_type == 1){
        if (aux_id < informative_RIDs){
            RID_type = RIDType::Informative;
        } else {
            RID_type = RIDType::RIDNotValid;
        }
    } else if (aux_type == 2){
        if (aux_id < low_severity_anomaly_RIDs){
            RID_type = RIDType::LowSeverityAnomaly;
        } else {
            RID_type = RIDType::RIDNotValid;
        }
    } else if (aux_type == 3){
        if (aux_id < medium_severity_anomaly_RIDs){
            RID_type = RIDType::MediumSeverityAnomaly;
        } else {
            RID_type = RIDType::RIDNotValid;
        }
    } else if (aux_type == 4){
        if (aux_id < high_severity_anomaly_RIDs){
         RID_type = RIDType::HighSeverityAnomaly;
        } else {
            RID_type = RIDType::RIDNotValid;
        }
    } else {
        RID_type = RIDType::RIDNotValid;
    }

    return RID_type;

}

function get_RID_enable_config_index(RID : u16) -> usize {

    var RID_type : RIDType = get_RID_type(RID);
    var index : usize = 4; //not valid index
    match RID_type {
        case Informative => {
            index = 0;
        }
        case LowSeverityAnomaly => {
            index = 1;
        }
        case MediumSeverityAnomaly => {
            index = 2;
        }
        case HighSeverityAnomaly => {
            index = 3;
        }
        case RIDNotValid => {
            index = 4;
        }
    }

    return index;
}

function get_RID_enable_config_offset(RID : u16) -> u8 {

    return (RID & offset_mask) as u8;
} 


function build_tm_5_x(p_tm_descriptor : &mut TMDescriptorT, tm_seq_counter: u16, event : &EventInfo, index : usize){

    var tm_packet_header : CCSDSPUSTMPacketHeaderT =
	                                     {packet_id = 0 : u16,
	                                      packet_seq_ctrl = 0 : u16,
	                                      packet_length = 0 : u16};
	var df_header : CCSDSPUSTMDFHeaderT =
									{version = 0 : u8,
	 								type = 0 : u8,
	 								subtype = 0 : u8,
	 								destinationID = 0 : u8};

	tm_packet_header.packet_id = ccsds_pus_tm_build_packet_id(0x32C : u16);

	tm_packet_header.packet_seq_ctrl = ccsds_pus_tm_build_packet_seq_ctrl(0x3 : u16, tm_seq_counter);
	

	tm_packet_header.packet_length = 5 + event->ev_aux_data_size as u16;

	df_header.version = ccsds_pus_tm_build_df_header_version(0x1 : u8);
	df_header.type = 5 : u8;
	df_header.subtype = (index + 1) as u8;
	df_header.destinationID = 0x78 : u8;


	ccsds_pus_tm_set_fields(&mut p_tm_descriptor->tm_bytes[0 : usize .. 10 : usize], &tm_packet_header, &df_header);

	serialize_uint16(event->ev_RID, &mut p_tm_descriptor->tm_bytes[14 : usize .. 16 : usize]);

	for i : usize in 0 .. event_aux_data_max_size while (i < event->ev_aux_data_size) {

        p_tm_descriptor->tm_bytes[16 + i] = event->ev_aux_data[i];
    }
	
	// Calculate p_tm_descriptor->tm_num_bytes
	p_tm_descriptor->tm_num_bytes = tm_packet_header.packet_length as usize + 7;

    return;
}
