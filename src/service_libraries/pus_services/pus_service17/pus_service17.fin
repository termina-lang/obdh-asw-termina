/**
 * @file pus_service17.fin
 * @brief Implementation of PUS Service 17 (Test Service)
 */

import service_libraries.pus_services.pus_service17.pus_service17_help;

/**
 * @interface PUSS17Iface
 * @brief Interface for PUS Service 17 resource.
 */
interface PUSS17Iface {
	procedure exec_tc (&mut self, tc_handler : &mut TCHandlerT, action_status: &mut Status<i32>);
};


/**
 * @class PUSService17
 * @brief Resource class implementing the PUS Service 17 Test functionality.
*/
resource class PUSService17 provides PUSS17Iface {

	/**
    * @brief Current status of the telecommand (TC) execution request.
    * 
    * Tracks the state of TC execution, such as initialization, execution, error,
    * failure, or exit states.
    */
    exec_tc_req_status : PSExecTCReqStatus;

    /**
    * @brief Structure holding updated status information for the TC execution request.
    * 
    * Used to report detailed execution results, acknowledgments, and flags related
    * to the telecommand processing.
    */
    exec_tc_req_status_update : PS17ExecTCReqStatusUpdate;

    /**
    * @brief Access to the telemetry (TM) channel interface.
    * 
    * Used to send telemetry packets generated by the service.
    */
    tm_channel : access TMChannelIface;

    /**
    * @brief Allocator for TMHandlerT objects.
    * 
    * Provides dynamic memory management for telemetry handler instances.
    */
    a_tm_handler_pool : access Allocator<TMHandlerT>;

    /**
    * @brief Interface for the telemetry packet counter.
    * 
    * Provides sequential TM packet counters to ensure proper numbering of packets.
    */
    tm_counter : access TMCounterIface;

    /**
    * @brief Access to PUS Service 9 interface.
    * 
    * Provides time-related services such as obtaining the current onboard time (OBT)
    * used for timestamping telemetry packets.
    */
    pus_service_9 : access PUSS9Iface;



    /**
     * @brief Executes the processing logic for TC[17,1].
     * 
     * Builds and sends TM[1,3], TM[17,2], and TM[1,7] based on the execution flow.
     * Handles resource allocation and error management.
     * 
     * @return Execution status after processing TC[17,1].
     */
	method exec17_1TC(&priv self) -> Status<i32> {

		var status : Status<i32> = Success;
        var ack_enabled : bool = false;

        var current_obt : MissionObt = {seconds = 0, finetime = 0};

        var tm_handler1 : Option<box TMHandlerT> = None;
		self->a_tm_handler_pool.alloc(&mut tm_handler1);

		match tm_handler1 {

			case Some(b_tm_handler1) => {

				var tm_count1 : u16 = 0 : u16;
				self->tm_counter.get_next_tm_count(&mut tm_count1);
				self->pus_service_9.get_current_obt(&mut current_obt);
                status = build_tm_1_3(&mut b_tm_handler1, tm_count1, (self->exec_tc_req_status_update.packet_id), (self->exec_tc_req_status_update.packet_seq_ctrl), self->exec_tc_req_status_update.flags_ack, current_obt, &mut ack_enabled);

                if (ack_enabled) {

                    if (status is Success){

                        self->tm_channel.send_tm(b_tm_handler1, &mut status);

                    }
                    else {
                        self->a_tm_handler_pool.free(b_tm_handler1);
                    }

                } else {
                    
                    self->a_tm_handler_pool.free(b_tm_handler1);
                }
				
			} 
			case None => {

				status = Failure(TM_POOL_ALLOC_FAILURE);
				
			}
			
		}
		
        if (status is Success) {

            var tm_handler2 : Option<box TMHandlerT> = None;
		    self->a_tm_handler_pool.alloc(&mut tm_handler2);

		    match tm_handler2 {

                case Some(b_tm_handler2) => {

                    var tm_count2 : u16 = 0 : u16;
                    
                    self->tm_counter.get_next_tm_count(&mut tm_count2);
                    self->pus_service_9.get_current_obt(&mut current_obt);
                    build_tm_17_2(&mut b_tm_handler2, tm_count2, current_obt);
                    self->tm_channel.send_tm(b_tm_handler2, &mut status);


                } 
                case None => {

                    status = Failure(TM_POOL_ALLOC_FAILURE);
                    
                }
			
		    }

        }

		
        if (status is Success){

            var tm_handler3 : Option<box TMHandlerT> = None;
		    self->a_tm_handler_pool.alloc(&mut tm_handler3);

            match tm_handler3 {

                case Some(b_tm_handler3) => {

                    var tm_count3 : u16 = 0 : u16;
                    self->tm_counter.get_next_tm_count(&mut tm_count3);
                    self->pus_service_9.get_current_obt(&mut current_obt);
                    status = build_tm_1_7(&mut b_tm_handler3, tm_count3, (self->exec_tc_req_status_update.packet_id), (self->exec_tc_req_status_update.packet_seq_ctrl), self->exec_tc_req_status_update.flags_ack, current_obt, &mut ack_enabled);
                    
                    if (ack_enabled) {

                        if (status is Success){

                            self->tm_channel.send_tm(b_tm_handler3, &mut status);

                        }
                        else {
                            self->a_tm_handler_pool.free(b_tm_handler3);
                        
                        }

                    } else {
                        
                        self->a_tm_handler_pool.free(b_tm_handler3);
                       
                    }
                } 
                case None => {

                    status = Failure(TM_POOL_ALLOC_FAILURE);
                    
                }
			
		    }

        }

		return status;
	}




    /**
     * @brief Executes a telecommand for PUS Service 17.
     * 
     * This function processes the TC in several stages depending on the current execution status.
     * Handles TM generation and error management.
     * 
     * @param tc_handler Pointer to the telecommand handler.
     * @param action_status Pointer to store the final execution status.
     */
	procedure exec_tc (&mut self, tc_handler : &mut TCHandlerT, action_status: &mut Status<i32>) {

        var status : Status<i32> = Success;
        var subtype : u8 = tc_handler->df_header.subtype;

        for i : usize in 0 .. 3 while (self->exec_tc_req_status is PSExecTCReqStatus::Exit == false) {

            match self->exec_tc_req_status {

				case Init => {
					// Do nothing
                    self->exec_tc_req_status_update.packet_id = tc_handler->packet_header.packet_id;
                    self->exec_tc_req_status_update.packet_seq_ctrl = tc_handler->packet_header.packet_seq_ctrl;
                    self->exec_tc_req_status_update.flags_ack = tc_handler->df_header.flag_ver_ack;
                    self->exec_tc_req_status = PSExecTCReqStatus::ExecTC;
				}

                case ExecTC => {

                    self->exec_tc_req_status = PSExecTCReqStatus::Exit;

                    if (subtype == 1) {

                        status = self->exec17_1TC();

                    } else {

                        status = Failure(ACCEPTANCE_ERROR);
            
                    }
                }
                case Exit => {
                    //Unreachable point
                }  
            }
        }

         match status {
                        
            case Success => {

                *action_status = Success;
    
            }
            case Failure(error_code) => {

                if (error_code == ACCEPTANCE_ERROR || error_code == BUILD_TM_ERROR) {

                    *action_status = Success;

                    var tm_handler : Option<box TMHandlerT> = None;
                    self->a_tm_handler_pool.alloc(&mut tm_handler);

                    match tm_handler {

                        case Some(b_tm_handler) => {

                            var tm_count : u16 = 0 : u16;
                            var current_obt : MissionObt = {seconds = 0, finetime = 0};
                            
                            self->tm_counter.get_next_tm_count(&mut tm_count);
                            self->pus_service_9.get_current_obt(&mut current_obt);

                            if (error_code == ACCEPTANCE_ERROR) {

                                status = build_tm_1_4_error_in_acceptance(&mut b_tm_handler, tm_count, (self->exec_tc_req_status_update.packet_id), (self->exec_tc_req_status_update.packet_seq_ctrl),
                                 current_obt);

                            } else if (error_code == BUILD_TM_ERROR) {

                                status = build_tm_1_8_tm_exceed_limit_appdata(&mut b_tm_handler, tm_count, (self->exec_tc_req_status_update.packet_id), (self->exec_tc_req_status_update.packet_seq_ctrl),
                                            current_obt);

                            } else {
                              

                            }

                            
                            
                            if (status is Success){

                                self->tm_channel.send_tm(b_tm_handler, &mut status);

                            } 
                            else {
                                self->a_tm_handler_pool.free(b_tm_handler);
                                
                            }
                            
                        }
                        case None => {
                            status = Failure(TM_POOL_ALLOC_FAILURE);
                        }
                    }
                    
                } else {

                    *action_status = Failure(error_code);
                    
                }   
                
            }  
        }

        self->exec_tc_req_status = PSExecTCReqStatus::Init;

        return;
    
    }

};



