/*
PUS SERVICE 9 : TIME MANAGEMENT
*/

import service_libraries.pus_services.pus_service9.pus_service9_help;

interface PUSS9Iface {

    procedure get_current_obt(&mut self, current_obt: &mut MissionObt);
    procedure exec_tc (&mut self, tc_handler : &mut TCHandlerT, result: &mut Result);

};

resource class PUSService9 provides PUSS9Iface {

    ref_obt : MissionObt;
    ref_time_val_from_power_on : TimeVal;
    exec_tc_req_status : PSExecTCReqStatus;
    exec_tc_req_status_update : PS9ExecTCReqStatusUpdate;

    tm_channel: access TMChannelIface;
    a_tm_handler_pool : access Allocator<TMHandlerT>;
    tm_counter : access TMCounterIface;

    system_port : access SystemAPI;

    method set_obt (&priv self) {
        self->ref_obt = self->exec_tc_req_status_update.next_OBT;
        var aux_time_val : TimeVal = {
            tv_sec = 0,
            tv_usec = 0
        };
        self->system_port.clock_get_uptime(&mut aux_time_val);
        self->ref_time_val_from_power_on = aux_time_val;

        return;
    }

    procedure get_current_obt(&mut self, current_obt: &mut MissionObt) {

        var fine_time_increment : u32 = 0;
        var time_val_from_power_on : TimeVal = {
            tv_sec = 0,
            tv_usec = 0
        };
        self->system_port.clock_get_uptime(&mut time_val_from_power_on);
        var interval : TimeVal = {
            tv_sec = 0,
            tv_usec = 0
        };

        interval = substract_TimeVal(time_val_from_power_on, self->ref_time_val_from_power_on);

        fine_time_increment = self->ref_obt.finetime as u32;
        fine_time_increment = fine_time_increment + (interval.tv_usec*1000)/15259;

        current_obt->seconds = self->ref_obt.seconds + interval.tv_sec + fine_time_increment >>16 : u32;
        current_obt->finetime = (fine_time_increment &0xFFFF) as u16;

        return;
    }

    viewer manage_short_pack_length_error(&self) -> PSExecTCReqStatus {

        var next_status : PSExecTCReqStatus = PSExecTCReqStatus::Error;
        var result : Result = Result::Ok;

        var tm_handler : Option<box TMHandlerT> = None;
        self->a_tm_handler_pool.alloc(&mut tm_handler);

        match tm_handler {

            case Some(b_tm_handler) => {

                var tm_count : u16 = 0 : u16;
                self->tm_counter.get_next_tm_count(&mut tm_count);

                build_tm_1_4_short_pack_length(&mut b_tm_handler, tm_count, (self->exec_tc_req_status_update.packet_id), 
                                            (self->exec_tc_req_status_update.packet_error_ctrl), (self->exec_tc_req_status_update.tc_num_bytes), &mut result);
                self->tm_channel.send_tm(b_tm_handler, &mut result);
            }
            case None => {
                result = Result::Error;
            }
        }

        if (result is Result::Error){

            next_status = PSExecTCReqStatus::Error;

        } else {

            next_status = PSExecTCReqStatus::Exit;

        }

        return next_status;
    }

    viewer get_TC_params(&self, tc_handler : &mut TCHandlerT, subtype : &mut u8, result : &mut Result) -> PS9ExecTCReqStatusUpdate {

        *subtype = tc_handler->df_header.subtype;

        var tc_data : PS9ExecTCReqStatusUpdate = {
            packet_id = 0,
            packet_error_ctrl = 0,
            tc_num_bytes = 0,
            next_OBT = {
                seconds = 0,
                finetime = 0
            }
        };
        tc_data.packet_id = tc_handler->packet_header.packet_id;
        tc_data.packet_error_ctrl = tc_handler->packet_error_ctrl;
        tc_data.tc_num_bytes = tc_handler->tc_descriptor.tc_num_bytes;
        *result = tc_handler_get_u32_appdata_field(tc_handler, &mut (tc_data.next_OBT.seconds));
        *result = tc_handler_get_u16_appdata_field(tc_handler, &mut (tc_data.next_OBT.finetime));
       

        return tc_data;

    }

    method exec9_129TC (&priv self) -> PSExecTCReqStatus {

        var result : Result = Result::Ok;
        var next_status : PSExecTCReqStatus = PSExecTCReqStatus::Error;

        var tm_handler : Option<box TMHandlerT> = None;
        self->a_tm_handler_pool.alloc(&mut tm_handler);

        match tm_handler {

            case Some(b_tm_handler) => {

                var tm_count : u16 = 0 : u16;
                self->tm_counter.get_next_tm_count(&mut tm_count);
                build_tm_1_3(&mut b_tm_handler, tm_count, &mut result);
                self->tm_channel.send_tm(b_tm_handler, &mut result);

                self->set_obt();

                var tm_handler2 : Option<box TMHandlerT> = None;
                self->a_tm_handler_pool.alloc(&mut tm_handler2);

                match tm_handler2 {

                    case Some(b_tm_handler2) => {

                        var tm_count2 : u16 = 0 : u16;
                        self->tm_counter.get_next_tm_count(&mut tm_count2);
                        build_tm_1_7(&mut b_tm_handler2, tm_count2, &mut result);
                        self->tm_channel.send_tm(b_tm_handler2, &mut result);
                    }
                    case None => {
                        result = Result::Error;
                    }
                }


            }
            case None => {

            }
        }

        if (result is Result::Error){

            next_status = PSExecTCReqStatus::Error;

        } else {

            next_status = PSExecTCReqStatus::Exit;

        }

        return next_status;

    }

    procedure exec_tc (&mut self, tc_handler : &mut TCHandlerT, result: &mut Result){

        var subtype : u8 = tc_handler->df_header.subtype;

        for i : usize in 0 .. 2 while (self->exec_tc_req_status is PSExecTCReqStatus::Exit == false) {

            match self->exec_tc_req_status {

                case Init => {

                    self->exec_tc_req_status_update = self->get_TC_params(tc_handler, &mut subtype, result);
                    if (*result is Result::Error) {
                        self->exec_tc_req_status = self->manage_short_pack_length_error();
                    } else {
                        self->exec_tc_req_status = PSExecTCReqStatus::ExecTC;
                    }

                }
                case ExecTC => {

                    if (subtype == 129) {

                        self->exec_tc_req_status = self->exec9_129TC();

                    } else {

                        self->exec_tc_req_status = PSExecTCReqStatus::Error;
                    }
                }

                case Error => {

                    *result = Result::Error;
                    self->exec_tc_req_status = PSExecTCReqStatus::Exit;

                }
                case Exit => {
                    //Unreachable point
                }  
            }
        }

        if(self->exec_tc_req_status is PSExecTCReqStatus::Exit){

            self->exec_tc_req_status = PSExecTCReqStatus::ExecTC;
        }

        return;
    
    }


};

