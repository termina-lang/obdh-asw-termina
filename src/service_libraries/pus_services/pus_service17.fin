/**
 * @file pus_service17.fin
 * @brief Implementation of PUS Service 17 (Test Service)
 */

import service_libraries.pus_services.pus_service1;
import resources.tm_channel;
import resources.obt_manager;

import service_libraries.pus_services.pus_service17.internal;

/**
 * @interface PUSS17Iface
 * @brief Interface for PUS Service 17 resource.
 */
interface PUSS17Iface {
    procedure exec_tc (&mut self, tc_handler : &mut TCHandler, action_status: &mut Status<i32>);
};


/**
 * @class PUSService17
 * @brief Resource class implementing the PUS Service 17 Test functionality.
*/
resource class PUSService17 provides PUSS17Iface {

    /**
     * @brief Structure holding updated status information for the TC execution request.
     * 
     * Used to report detailed execution results, acknowledgments, and flags related
     * to the telecommand processing.
     */
    exec_tc_req_status_update : PS17ExecTCReqStatusUpdate;

    /**
     * @brief Access to the telemetry (TM) channel interface.
     * 
     * Used to send telemetry packets generated by the service.
     */
    tm_channel : access TMChannelIface;

    /**
    * @brief Allocator for TMHandlerT objects.
    * 
    * Provides dynamic memory management for telemetry handler instances.
    */
    a_tm_handler_pool : access Allocator<TMHandler>;

    /**
    * @brief Interface for the telemetry packet counter.
    * 
    * Provides sequential TM packet counters to ensure proper numbering of packets.
    */
    tm_counter : access TMCounterIface;

    /**
    * @brief Access to the On-Board Time manager resource.
    * 
    * Provides time-related services such as obtaining the current onboard time (OBT)
    * used for timestamping telemetry packets.
    */
    obt_manager : access OBTManagerIface;

    pus_service_1 : access PUSService1Iface;

    /**
     * @brief Executes the processing logic for TC[17,1].
     * 
     * Builds and sends TM[1,3], TM[17,2], and TM[1,7] based on the execution flow.
     * Handles resource allocation and error management.
     * 
     * @return Execution status after processing TC[17,1].
     */
    method exec17_1TC(&priv self) -> Status<i32> {

        var status : Status<i32> = Success;

        self->pus_service_1.notify_tm_1_3(
                    self->exec_tc_req_status_update.packet_id,
                    self->exec_tc_req_status_update.packet_seq_ctrl,
                    self->exec_tc_req_status_update.flags_ack,
                    &mut status);

        
        if (status is Success) {

            var current_obt : MissionOBT = {seconds = 0, finetime = 0};
            var tm_count : u16 = 0 : u16;

            var tm_handler : Option<box TMHandler> = None;
            self->a_tm_handler_pool.alloc(&mut tm_handler);

            match tm_handler {

                case Some(b_tm_handler) => {

                    self->tm_counter.get_next_tm_count(&mut tm_count);
                    self->obt_manager.get_current_obt(&mut current_obt);
                    build_tm_17_2(&mut b_tm_handler, tm_count, current_obt);
                    self->tm_channel.send_tm(b_tm_handler, &mut status);

                } 
                case None => {

                    status = Failure(TM_POOL_ALLOC_FAILURE);
                    
                }
            
            }

        }
        
        if (status is Success) {

            self->pus_service_1.notify_tm_1_7(
                    self->exec_tc_req_status_update.packet_id,
                    self->exec_tc_req_status_update.packet_seq_ctrl,
                    self->exec_tc_req_status_update.flags_ack, 
                    &mut status);

        }

        return status;
    }

    /**
     * @brief Executes a telecommand for PUS Service 17.
     * 
     * This function processes the TC in several stages depending on the current execution status.
     * Handles TM generation and error management.
     * 
     * @param tc_handler Pointer to the telecommand handler.
     * @param action_status Pointer to store the final execution status.
     */
    procedure exec_tc (&mut self, tc_handler : &mut TCHandler, action_status: &mut Status<i32>) {

        var status : Status<i32> = Success;
        var subtype : u8 = tc_handler->df_header.subtype;

        self->exec_tc_req_status_update.packet_id = tc_handler->packet_header.packet_id;
        self->exec_tc_req_status_update.packet_seq_ctrl = tc_handler->packet_header.packet_seq_ctrl;
        self->exec_tc_req_status_update.flags_ack = tc_handler->df_header.flag_ver_ack;


        if (subtype == 1) {

            status = self->exec17_1TC();

        } else {

            status = Failure(ACCEPTANCE_ERROR);
            
        }

         match status {
                        
            case Success => {

                *action_status = Success;
    
            }
            case Failure(error_code) => {


                if (error_code == ACCEPTANCE_ERROR) {

                    self->pus_service_1.send_tm_1_4_error_in_acceptance(
                                self->exec_tc_req_status_update.packet_id,
                                self->exec_tc_req_status_update.packet_seq_ctrl,
                                action_status);

                } else if (error_code == BUILD_TM_ERROR) {

                    self->pus_service_1.send_tm_1_8_tm_exceed_limit_appdata(
                                self->exec_tc_req_status_update.packet_id,
                                self->exec_tc_req_status_update.packet_seq_ctrl,
                                action_status);

                } else {

                    *action_status = Failure(error_code);
                    
                }   
                
            }  
        }

        return;
    
    }

};



