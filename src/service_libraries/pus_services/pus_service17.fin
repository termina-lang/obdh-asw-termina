/*
PUS SERVICE 17 : TEST
*/

import service_libraries.tm_ccsds_pus_format;
import service_libraries.tc_ccsds_pus_format;

function build_tm_17_2(tm_descriptor : &mut TMDescriptorT,
					tm_seq_counter : u16) {

	var tm_packet_header : CCSDSPUSTMPacketHeaderT =
	                                     {packet_id = 0 : u16,
	                                      packet_seq_ctrl = 0 : u16,
	                                      packet_length = 0 : u16};
	var df_header : CCSDSPUSTMDFHeaderT =
										{version = 0 : u8,
	 									type = 0 : u8,
	 									subtype = 0 : u8,
	 									destinationID = 0 : u8};

	tm_packet_header.packet_id = ccsds_pus_tm_build_packet_id(0x32C);

	tm_packet_header.packet_seq_ctrl = ccsds_pus_tm_build_packet_seq_ctrl(0x3, tm_seq_counter);
	

	tm_packet_header.packet_length = 3;

	df_header.version = ccsds_pus_tm_build_df_header_version(0x1);
	df_header.type = 17;
	df_header.subtype = 2;
	df_header.destinationID = 0x78;

	ccsds_pus_tm_set_fields(&mut tm_descriptor->tm_bytes[0 : usize .. 10 : usize], &tm_packet_header, &df_header);
			
	// Calculate p_tm_descriptor->tm_num_bytes
	tm_descriptor->tm_num_bytes = tm_packet_header.packet_length as usize + 7;

	return;

}

interface PUSS17Iface {
	procedure exec17_1TC(&mut self, tc_descriptor : &TCDescriptorT, result : &mut Result);
};

resource class PUSService17 provides PUSS17Iface {

	tm_channel: access TMChannelIface;   
    a_tm_descriptor_pool : access Allocator<TMDescriptorT>;
    tm_counter : access TMCounterIface;

	procedure exec17_1TC(&mut self, tc_descriptor : &TCDescriptorT, result : &mut Result) {

		var subtype : u8 = get_subtype(&(tc_descriptor->tc_bytes));
		
		if (subtype == 1){

			var tm_descriptor : Option<box TMDescriptorT> = None;
			self->a_tm_descriptor_pool.alloc(&mut tm_descriptor);

			match tm_descriptor {

				case Some(descriptor) => {

					var tm_count : u16 = 0 : u16;
					self->tm_counter.get_next_tm_count(&mut tm_count);
					build_tm_17_2(&mut descriptor, tm_count);
					self->tm_channel.send_tm(descriptor, result);
				} 
				case None => {
					*result = Result::Error;
				}
			}
		}

    	return;
	}

};



