/*
PUS SERVICE 2 : DEVICE ACCESS
*/

import resources.gpio_driver;
import service_libraries.pus_services.pus_service1;
import service_libraries.serialize;
import service_libraries.tc_ccsds_pus_format;
import service_libraries.tm_ccsds_pus_format;
import service_libraries.pus_services.pus_service2.types;



/* Se pueden encender y apagar cuatros dispositivos, simulados mediante el uso de cuatro leds */
// DISP <--> LED <--> address ON, OFF
// DISP 1 <--> LED 0 <--> 0x00000001, 0x00000000
// DISP 2 <--> LED 1 <--> 0x10000001, 0x10000000
// DISP 3 <--> LED 2 <--> 0x20000001, 0x20000000
// DISP 4 <--> LED 3 <--> 0x30000001, 0x30000000

interface PUSS2Iface {

    procedure exec_tc (&mut self, tc_handler : &mut TCHandler, action_status: &mut Status<i32>);

};


resource class PUSService2 provides PUSS2Iface {

    exec_tc_req_status_update : PS2ExecTCReqStatusUpdate;

    pus_service_1 : access PUSService1Iface;

    gpio_driver : access GPIODrvIface;

    method exec2_1TC(&priv self) -> Status<i32> {

        var status : Status<i32> = Success;

        if self->exec_tc_req_status_update.N != 1 {

            self->pus_service_1.send_tm_1_4_num_of_instr_not_valid(
                    self->exec_tc_req_status_update.packet_id,
                    self->exec_tc_req_status_update.packet_seq_ctrl, 
                    self->exec_tc_req_status_update.N, &mut status);

        } else if self->device_drv_is_on_off_address_valid() == false {

            self->pus_service_1.send_tm_1_4_device_address_not_valid(
                    self->exec_tc_req_status_update.packet_id,
                    self->exec_tc_req_status_update.packet_seq_ctrl,
                    self->exec_tc_req_status_update.dev_address, &mut status);

        } else { 

            self->pus_service_1.notify_tm_1_3(
                        self->exec_tc_req_status_update.packet_id, 
                        self->exec_tc_req_status_update.packet_seq_ctrl,
                        self->exec_tc_req_status_update.flags_ack,
                        &mut status);

            if (status is Success) {

                status = self->dev_drv_on_off();
            
                if (status is Success) {

                    self->pus_service_1.notify_tm_1_7(
                                self->exec_tc_req_status_update.packet_id,
                                self->exec_tc_req_status_update.packet_seq_ctrl,
                                self->exec_tc_req_status_update.flags_ack,
                                &mut status);

                } else {

                    self->pus_service_1.send_tm_1_8_device_command_exec_error(
                                self->exec_tc_req_status_update.packet_id,
                                self->exec_tc_req_status_update.packet_seq_ctrl,
                                self->exec_tc_req_status_update.dev_address,
                                &mut status);

                }

            }
        
        }

        return status;
    }

    method device_drv_is_on_off_address_valid(&self) -> bool {

        var is_valid : bool = false;
        var device_address : u32 = self->exec_tc_req_status_update.dev_address;

        if (device_address == 0x60000001 
            || device_address == 0x70000001 
            || device_address == 0x80000001 
            || device_address == 0x90000001 
            || device_address == 0x60000000 
            || device_address == 0x70000000 
            || device_address == 0x80000000
            || device_address == 0x90000000) {
            is_valid = true;
        }

        return is_valid;

    }

    method dev_drv_on_off(&priv self) -> Status<i32> {

        var status : Status<i32> = Success;

        var led: u8 = ((self->exec_tc_req_status_update.dev_address & 0xF0000000) >> 28 : u32) as u8;
        var on_off : u8 = (self->exec_tc_req_status_update.dev_address & 0x0000000F) as u8;

        self->gpio_driver.write_led(led, on_off, &mut status);

        return status;
    }

    procedure exec_tc (&mut self, tc_handler : &mut TCHandler, action_status: &mut Status<i32>){

        var status : Status<i32> = Success; 
        var subtype : u8 = tc_handler->df_header.subtype;

        self->exec_tc_req_status_update.packet_id = tc_handler->packet_header.packet_id;
        self->exec_tc_req_status_update.packet_seq_ctrl = tc_handler->packet_header.packet_seq_ctrl;
        self->exec_tc_req_status_update.flags_ack = tc_handler->df_header.flag_ver_ack;
        self->exec_tc_req_status_update.tc_num_bytes = tc_handler->tc_descriptor.tc_num_bytes;

        status = tc_handler_get_u8_appdata_field(tc_handler, &mut self->exec_tc_req_status_update.N);

        if (status is Success) {
            status = tc_handler_get_u32_appdata_field(tc_handler, &mut self->exec_tc_req_status_update.dev_address);
        }

        if (status is Success) {
        
            if (subtype == 1) {

                status = self->exec2_1TC();

            } else {

                status = Failure(ACCEPTANCE_ERROR);
            }

        }

        match status {
                        
            case Success => {

                *action_status = Success;
    
            }
            case Failure(error_code) => {

                if (error_code == ACCEPTANCE_ERROR) {

                    self->pus_service_1.send_tm_1_4_error_in_acceptance(
                                    self->exec_tc_req_status_update.packet_id,
                                    self->exec_tc_req_status_update.packet_seq_ctrl,
                                    action_status);

                } else if (error_code == BUILD_TM_ERROR) {

                    self->pus_service_1.send_tm_1_8_tm_exceed_limit_appdata(
                                    self->exec_tc_req_status_update.packet_id,
                                    self->exec_tc_req_status_update.packet_seq_ctrl,
                                    action_status);

                } else if (error_code == TC_DATA_OUT_OF_RANGE_ERROR) {

                    self->pus_service_1.send_tm_1_4_short_pack_length(
                                    self->exec_tc_req_status_update.packet_id,
                                    self->exec_tc_req_status_update.packet_seq_ctrl,
                                    self->exec_tc_req_status_update.tc_num_bytes,
                                    action_status);

                } else {
                    
                    *action_status = Failure(error_code);

                }

            }
        }

        return;
    
    }

};
