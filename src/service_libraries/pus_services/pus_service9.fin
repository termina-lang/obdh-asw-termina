/**
 * @file pus_service9.fin
 * @brief Implementation of PUS Service 9: Time Management.
 */

import service_libraries.pus_tm_handler;
import resources.tm_channel;
import service_libraries.pus_services.pus_service1;
import service_libraries.pus_services.pus_service9.types;


/**
 * @interface PUSS9Iface
 * @brief Interface for PUS Service 9 Time Management.
 *
 * Defines the methods required to get the current on-board time (OBT) and
 * to execute telecommands related to time managemen service.
 */
interface PUSS9Iface {

    procedure exec_tc (&mut self, tc_handler : &mut TCHandler, action_status: &mut Status<i32>);

};

/**
 * @resourceclass PUSService9
 * @brief Resource class implementing PUS Service 9: Time Management.
 *
 * Provides on-board time tracking, telecommand execution, and telemetry generation
 * for time management telecommands according to PUS specifications. It implements
 * the PUSS9Iface interface.
 */
resource class PUSService9 provides PUSS9Iface {

    exec_tc_req_status_update : PS9ExecTCReqStatusUpdate; /**< Data extracted from the telecommand */

    obt_manager : access OBTManagerIface;

    pus_service_1 : access PUSService1Iface;

    /**
     * @brief Execute TC subtype 129 (specific time management TC - set current OBT).
     *
     * Handles execution of the TC with subtype 129 by generating telemetry
     * reports TM[1,3] and TM[1,7] as acknowledgments, updating internal status,
     * and managing telemetry handler resources.
     *
     * @return PSExecTCReqStatus Status of TC execution (Exit, Failure, or Error).
     */
    method exec9_129TC (&priv self) -> Status<i32> {

        var status : Status<i32> = Success;

        self->pus_service_1.notify_tm_1_3(
                self->exec_tc_req_status_update.packet_id,
                self->exec_tc_req_status_update.packet_seq_ctrl,
                self->exec_tc_req_status_update.flags_ack, 
                &mut status);

        if (status is Success) {
                
            self->obt_manager.set_obt(self->exec_tc_req_status_update.next_OBT);

            self->pus_service_1.notify_tm_1_7(
                    self->exec_tc_req_status_update.packet_id,
                    self->exec_tc_req_status_update.packet_seq_ctrl,
                    self->exec_tc_req_status_update.flags_ack, 
                    &mut status);
        
        }

        return status;

    }

    /**
     * @brief Execute a time management telecommand.
     *
     * Main telecommand execution procedure that manages the TC lifecycle,
     * including parameter extraction, execution based on subtype, and error handling.
     *
     * @param[in,out] tc_handler Reference to the telecommand handler.
     * @param[in,out] action_status Status variable updated with execution outcome.
    */
    procedure exec_tc (&mut self, tc_handler : &mut TCHandler, action_status: &mut Status<i32>){

        var status : Status<i32> = Success;
        var subtype : u8 = tc_handler->df_header.subtype;

        self->exec_tc_req_status_update.packet_id = tc_handler->packet_header.packet_id;
        self->exec_tc_req_status_update.packet_seq_ctrl = tc_handler->packet_header.packet_seq_ctrl;
        self->exec_tc_req_status_update.flags_ack = tc_handler->df_header.flag_ver_ack;
        self->exec_tc_req_status_update.tc_num_bytes = tc_handler->tc_descriptor.tc_num_bytes;

        status = tc_handler_get_u32_appdata_field(tc_handler, &mut (self->exec_tc_req_status_update.next_OBT.seconds));

        if (status is Success) {
            status = tc_handler_get_u16_appdata_field(tc_handler, &mut (self->exec_tc_req_status_update.next_OBT.finetime));
        }

        if (status is Success) {

            if (subtype == 129) {

                status = self->exec9_129TC();

            } else {

                status = Failure(ACCEPTANCE_ERROR);
                
            }

        }

        match status {
                        
            case Success => {

                *action_status = Success;
    
            }
            case Failure(error_code) => {

                if (error_code == ACCEPTANCE_ERROR) {

                    self->pus_service_1.send_tm_1_4_error_in_acceptance(
                            self->exec_tc_req_status_update.packet_id,
                            self->exec_tc_req_status_update.packet_seq_ctrl,
                            action_status);

                } else if (error_code == BUILD_TM_ERROR) {

                    self->pus_service_1.send_tm_1_8_tm_exceed_limit_appdata(
                            self->exec_tc_req_status_update.packet_id,
                            self->exec_tc_req_status_update.packet_seq_ctrl,
                            action_status);

                } else if (error_code == TC_DATA_OUT_OF_RANGE_ERROR) {

                    self->pus_service_1.send_tm_1_4_short_pack_length(
                            self->exec_tc_req_status_update.packet_id,
                            self->exec_tc_req_status_update.packet_seq_ctrl,
                            self->exec_tc_req_status_update.tc_num_bytes,
                            action_status);

                } else {
                  
                    *action_status = Failure(error_code);
                
                }
                
            }  
        }

        return;
    
    }


};

