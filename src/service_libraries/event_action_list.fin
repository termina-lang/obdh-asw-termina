const event_action_queue_dimension : usize = 8;
const event_action_max_bytes : usize = 242;

enum ListResult {
    Success,
    ListFull
};


struct EventActionList {
    pending_actions : [TCDescriptorT; event_action_queue_dimension];
    pending_action_number: usize;
    pending_action_head: usize;
};


function is_list_full(list: &EventActionList) -> bool {
    var list_is_full: bool = (list->pending_action_number == event_action_queue_dimension);
    return list_is_full;
}

function is_list_empty(list : &EventActionList) -> bool {
    var list_is_empty: bool = (list->pending_action_number == 0: usize);
    return list_is_empty;
}

function add_evaction(list: &mut EventActionList, new_evaction: &TCDescriptorT) -> ListResult {

    var full: bool = is_list_full(&(*list)); 
    var result: ListResult = ListResult::Success;

    if (false == full) {

        list->pending_actions[list->pending_action_number] = *new_evaction;
        list->pending_action_number = list->pending_action_number + 1: usize;

        if (new_evaction.num_events > event_action_max_bytes) {

            list->pending_actions[list->pending_action_number].num_events = event_action_max_bytes;

        } else {

            list->pending_actions[list->pending_action_number].num_events = new_evaction.num_events;
        }

        for i : usize in 0 : usize .. event_action_max_bytes while (i < list->pending_actions[list->pending_action_number].num_events) {

            list->pending_actions[list->pending_action_number].ev_aux_data[i] = new_evaction.ev_aux_data[i];
        }

    } else {
        result = ListResult::ListFull;
    }
    return result;
}

function extract_event(list: &mut EventList, ext_event: &mut Option<EventInfo>) {

    var empty: bool = is_list_empty(&(*list));

    if (false == empty) {
        var event: EventInfo = list->pending_actions[0];
        *ext_event = Some(event);
        for i : usize in 0 : usize .. max_num_events while i < list->pending_action_number {
            list->pending_actions[i] = list->pending_actions[i + 1];
        }
        list->pending_action_number = list->pending_action_number - 1: usize;
    } else {
        *ext_event = None;
    }
    return;
}

function get_event_info(list: &EventList, index: usize, event: &mut EventInfo) {
    
    if (index < list->pending_action_number) {
        *event = list->pending_actions[index];
    }

    return;
}

function clear_ev_list(list: &mut EventList) {
    list->pending_action_number = 0;
    return;
}