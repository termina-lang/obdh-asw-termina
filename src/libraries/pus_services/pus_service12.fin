/*
PUS SERVICE 12 : ON-BOARD MONITORING
*/

import libraries.tc_ccsds_pus_format;
import libraries.tm_ccsds_pus_format;
import libraries.serialize;
import libraries.pus_services.pus_service1;
import libraries.pus_services.pus_service3;
import libraries.event_list;
import resources.system_data_pool;


const max_num_pmon_ids : usize = 8;

enum CheckState {
    MonitorUnselected,
    MonitorUnchecked,
    MonitorAboveHighLimit,
    MonitorBelowLowLimit,
    MonitorWithinLimits
};

struct ParamMonitoringConfiguration {
    prev_state : CheckState;
    state : CheckState;
    transitionY2K : TimeVal;
    enabled : bool;
    PID : u16;
    interval : u8;
    interval_control : u8;
};


struct ParamLimitCheckDefinition {
    high_limit_rid : u16;
    high_limit : u16;
    low_limit_rid : u16;
    low_limit : u16;
};


function exec12_1TC(tc_descriptor: &TCDescriptorT , tm_descriptor: &mut TMDescriptorT, tm_seq_counter: u16,
                 param_mon_config_table: &mut [ParamMonitoringConfiguration; max_num_pmon_ids]){
                 

    var PMONID : usize = tc_descriptor->tc_bytes[10] as usize;

    if (PMONID < max_num_pmon_ids) {

        if(param_mon_config_table[PMONID].state is CheckState::MonitorUnselected == false){

            param_mon_config_table[PMONID].enabled = true;
            param_mon_config_table[PMONID].interval_control = 0;
            build_tm_1_7(tm_descriptor, tm_seq_counter, tc_descriptor);
        } else {

            build_tm_1_8_tc_12_X_PMONIDundefined(tm_descriptor, tm_seq_counter, PMONID as u16, tc_descriptor);
        }
    } else {

        build_tm_1_8_tc_12_X_PMONIDnotvalid(tm_descriptor, tm_seq_counter, PMONID as u16, tc_descriptor);
    }
    return;
}



function exec12_2TC(tc_descriptor: &TCDescriptorT , tm_descriptor: &mut TMDescriptorT, tm_seq_counter: u16,
                 param_mon_config_table: &mut [ParamMonitoringConfiguration; max_num_pmon_ids]){

    var PMONID : usize = tc_descriptor->tc_bytes[10] as usize;

    if (PMONID < max_num_pmon_ids) {

        if(param_mon_config_table[PMONID].state is CheckState::MonitorUnselected == false){

            param_mon_config_table[PMONID].enabled = false;
            build_tm_1_7(tm_descriptor, tm_seq_counter, tc_descriptor);
            
        } else {

            build_tm_1_8_tc_12_X_PMONIDundefined(tm_descriptor, tm_seq_counter, PMONID as u16, tc_descriptor);
        }
    } else {

        build_tm_1_8_tc_12_X_PMONIDnotvalid(tm_descriptor, tm_seq_counter, PMONID as u16, tc_descriptor);
    }
    return;
}



function exec12_5TC(tc_descriptor: &TCDescriptorT , tm_descriptor: &mut TMDescriptorT, tm_seq_counter: u16,
                 param_mon_config_table: &mut [ParamMonitoringConfiguration; max_num_pmon_ids],
                 param_limit_check_definition : &mut [ParamLimitCheckDefinition; max_num_pmon_ids]){

    var PMONID : usize = deserialize_uint16(&(tc_descriptor->tc_bytes[10..12])) as usize;

    if (PMONID) < max_num_pmon_ids {

        if(param_mon_config_table[PMONID].state is CheckState::MonitorUnselected) {

            var PID : u16 = deserialize_uint16(&(tc_descriptor->tc_bytes[12..14]));

            if (PID as usize < SDP_num_params) {

                param_mon_config_table[PMONID].interval = tc_descriptor->tc_bytes[14];
                param_mon_config_table[PMONID].PID = PID;
                param_mon_config_table[PMONID].interval_control = 0;
                param_mon_config_table[PMONID].state = CheckState::MonitorUnchecked;

                param_limit_check_definition[PMONID].low_limit = deserialize_uint16(&(tc_descriptor->tc_bytes[15..17]));
                param_limit_check_definition[PMONID].low_limit_rid = deserialize_uint16(&(tc_descriptor->tc_bytes[17..19]));
                param_limit_check_definition[PMONID].high_limit = deserialize_uint16(&(tc_descriptor->tc_bytes[19..21]));
                param_limit_check_definition[PMONID].high_limit_rid = deserialize_uint16(&(tc_descriptor->tc_bytes[21..23]));

                build_tm_1_7(tm_descriptor, tm_seq_counter, tc_descriptor);

            } else {

                build_tm_1_8_tc_20_X_PIDnotvalid(tm_descriptor, tm_seq_counter, PID, tc_descriptor);
            }
        } else {

            build_tm_1_8_tc_12_X_PMONIDdefined(tm_descriptor, tm_seq_counter, PMONID as u16, tc_descriptor);
        }
    } else {

        build_tm_1_8_tc_12_X_PMONIDnotvalid(tm_descriptor, tm_seq_counter, PMONID as u16, tc_descriptor);
    }

    return;

}


function PUS_service_12_execTC (tc_descriptor : &TCDescriptorT, tm_descriptor : &mut TMDescriptorT, tm_seq_counter: u16,
                                param_mon_config_table : &mut [ParamMonitoringConfiguration; max_num_pmon_ids],
                                param_limit_check_definition : &mut [ParamLimitCheckDefinition; max_num_pmon_ids]){

    var subtype : u8 = get_subtype(&(tc_descriptor->tc_bytes));
    
    if (subtype == 1){

        exec12_1TC(tc_descriptor, tm_descriptor, tm_seq_counter, param_mon_config_table);
    } 
    else if (subtype == 2){

        exec12_2TC(tc_descriptor, tm_descriptor, tm_seq_counter, param_mon_config_table);

    } else if (subtype == 5){

        exec12_5TC(tc_descriptor, tm_descriptor, tm_seq_counter, param_mon_config_table, param_limit_check_definition);

    } else {

        //This is an error in acceptance, could be modeled as an event
        /* If the acceptance process is correct, this point should not be reached */
    }

    return;
}


function trigger_event(event_list : &mut EventList, RID: u16, PID: u16, PID_value: u16, limit: u16, res: &mut Result){

    var ev_info : EventInfo = {
        ev_RID = RID,
        ev_aux_data = [0;event_aux_data_max_size],
        ev_aux_data_size = 6
    };

    serialize_uint16(PID, &mut (ev_info.ev_aux_data[0..2]));
    serialize_uint16(PID_value, &mut (ev_info.ev_aux_data[2..4]));
    serialize_uint16(limit, &mut (ev_info.ev_aux_data[4..6]));

    var result : ListResult = add_event(event_list, ev_info);

    if result is ListResult::ListFull {

        *res = Result::Error;

    } else {

        *res = Result::Ok;

    }
    return;

}


function update_state (param_mon_config_table : &mut [ParamMonitoringConfiguration; max_num_pmon_ids], PMONID: usize, new_state : CheckState){

    if (PMONID < max_num_pmon_ids){

        param_mon_config_table[PMONID].prev_state = param_mon_config_table[PMONID].state;
        param_mon_config_table[PMONID].state = new_state;
        clock_get_uptime(&mut param_mon_config_table[PMONID].transitionY2K);
    }

    return;
}