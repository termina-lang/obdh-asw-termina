/*
PUS SERVICE 19 : EVENT-ACTION
*/

import libraries.pus_services.pus_service5;
import libraries.pus_services.pus_service1;
import libraries.serialize;
import libraries.tc_ccsds_pus_format;
import libraries.tm_ccsds_pus_format;


const max_event_action_definitions : usize = 16;
const event_action_queue_dimension : usize = 8;
const event_action_max_bytes : usize = 242;

struct EventActionConfig {
    enabled: bool;
    event_ID: u16;
};
//I think not needed
/*
struct EventActionPacket {
    action_packet_bytes: [u8; event_action_max_bytes];
    tc_descriptor: TCDescriptorT;
};
*/

function get_event_action_config (evID: u16, index: &mut usize, enabled: &mut bool, event_action_config_table: &[EventActionConfig; max_event_action_definitions]) -> bool {

    var found: bool = false;

    for i : usize in 0 .. max_event_action_definitions while found == false {

        if (event_action_config_table[i].event_ID == evID) {

                *index = i;
                *enabled = event_action_config_table[i].enabled;
                found = true;
        }
    }
    return found;
   
}

function get_free_event_action_index (index: &mut usize, event_action_config_table: &[EventActionConfig; max_event_action_definitions])->bool {

    var found: bool = false;

    for i : usize in 0 .. max_event_action_definitions while found == false {

        if (event_action_config_table[i].event_ID == 0) {

            *index = i;
            found = true;
        }
    }
    return found;
}

//TC[19,1] allows the addition of event-action definitions
function exec19_1TC (tc_descriptor: &TCDescriptorT , tm_descriptor: &mut TMDescriptorT, tm_seq_counter: u16, event_action_config_table: &mut [EventActionConfig; max_event_action_definitions],
                        event_action_packs: &mut [TCDescriptorT; max_event_action_definitions]){

    var index : usize = 0;
    var found : bool = false;
    var enabled : bool = false;
    var evID : u16 = deserialize_uint16(&(tc_descriptor->tc_bytes[10 : usize .. 12 : usize]));
    var event_type : RIDType = get_RID_type(evID);

    if(event_type is RIDType::RIDNotValid){

        build_tm_1_8_tc_5_X_RIDunknown(tm_descriptor, tm_seq_counter, evID, tc_descriptor);
					
    } else {
        /*Here a function is used as a value. I think this souldn't work as Termina is not a higher-order programming language
        The transpilation is right*/
        if (get_event_action_config(evID, &mut index, &mut enabled, &(*event_action_config_table))){

            found = true;

        } else if(get_free_event_action_index (&mut index, &(*event_action_config_table))){

            found = true;
            enabled = false;

        } else {

           //Not found means the maximun of event-action definitions has been reached
            build_tm_1_8_tc_19_1_max_event_actions(tm_descriptor, tm_seq_counter, evID, tc_descriptor);

        }

        if (found){

            if (enabled){ //Event-action can't be redefined if it is enabled

                build_tm_1_8_tc_19_X_event_action_enabled(tm_descriptor, tm_seq_counter, evID, tc_descriptor);

            } else {

                var action_packet_length : usize = get_packet_length(&(tc_descriptor->tc_bytes)) as usize - 7;
                //TO CHECK 
                
                for i : usize in 0 .. event_action_max_bytes while i < action_packet_length {

                    (*event_action_packs)[index].tc_bytes[i] = tc_descriptor->tc_bytes[i + 12];

                }

                event_action_packs[index].tc_num_bytes = action_packet_length;
                
                var tc_status : TCStatus = {
                    acceptation_status = TCAcceptationStatus::Rejected,
                    execution_status = TCExecutionCtrl:: ExecCtrlPrioTC,
                    error_code =  TCErrorType::CRCError
                };

                try_tc_acceptation(&mut tc_status, &(*event_action_packs)[index]);

                if (tc_status.acceptation_status is TCAcceptationStatus::Accepted){
                
                    event_action_config_table[index].event_ID = evID;
                    event_action_config_table[index].enabled = false;
                    
                    build_tm_1_7(tm_descriptor, tm_seq_counter, tc_descriptor);
                   

                } else {

                    build_tm_1_8_tc_19_1_event_action_rejected(tm_descriptor, tm_seq_counter, evID, tc_descriptor);

                }
            }         

        }
    }

   return; 
}


//TC[19,2] allows the deletion of event-action definitions
function exec19_2TC (tc_descriptor: &TCDescriptorT , tm_descriptor: &mut TMDescriptorT, tm_seq_counter: u16, event_action_config_table: &mut [EventActionConfig; max_event_action_definitions]){

    var index : usize = 0;
    var enabled : bool = false;
    var evID : u16 = deserialize_uint16(&(tc_descriptor->tc_bytes[10 : usize .. 12 : usize]));
    var event_type : RIDType = get_RID_type(evID);

    if (event_type is RIDType::RIDNotValid){

        build_tm_1_8_tc_5_X_RIDunknown(tm_descriptor, tm_seq_counter, evID, tc_descriptor);

    } else {

        if (get_event_action_config(evID, &mut index, &mut enabled, &(*event_action_config_table))){

            if (enabled){
                    
                    build_tm_1_8_tc_19_X_event_action_enabled(tm_descriptor, tm_seq_counter, evID, tc_descriptor);
    
                } else {
    
                    event_action_config_table[index].event_ID = 0;
                    event_action_config_table[index].enabled = false;
    
                    build_tm_1_7(tm_descriptor, tm_seq_counter, tc_descriptor);
            }

        } else {

            build_tm_1_8_tc_19_X_event_action_not_defined(tm_descriptor, tm_seq_counter, evID, tc_descriptor);

        }
    }

  return;              
}


//TC[19,4] allows enabling event-action definitions
function exec19_4TC (tc_descriptor: &TCDescriptorT , tm_descriptor: &mut TMDescriptorT, tm_seq_counter: u16, event_action_config_table: &mut [EventActionConfig; max_event_action_definitions]){

    var index : usize = 0;
    var enabled : bool = false;
    var evID : u16 = deserialize_uint16(&(tc_descriptor->tc_bytes[10 : usize .. 12 : usize]));
    var event_type : RIDType = get_RID_type(evID);

    if (event_type is RIDType::RIDNotValid){

        build_tm_1_8_tc_5_X_RIDunknown(tm_descriptor, tm_seq_counter, evID, tc_descriptor);

    } else {

        if (get_event_action_config(evID, &mut index, &mut enabled, &(*event_action_config_table))){

            event_action_config_table[index].enabled = true;
            build_tm_1_7(tm_descriptor, tm_seq_counter, tc_descriptor);

        } else {

            build_tm_1_8_tc_19_X_event_action_not_defined(tm_descriptor, tm_seq_counter, evID, tc_descriptor);

        }
    }
    return;
}


//TC[19,5] allows disabling event-action definitions
function exec19_5TC (tc_descriptor: &TCDescriptorT , tm_descriptor: &mut TMDescriptorT, tm_seq_counter: u16, event_action_config_table: &mut [EventActionConfig; max_event_action_definitions]){

    var index : usize = 0;
    var enabled : bool = false;
    var evID : u16 = deserialize_uint16(&(tc_descriptor->tc_bytes[10 : usize .. 12 : usize]));
    var event_type : RIDType = get_RID_type(evID);

    if (event_type is RIDType::RIDNotValid){

        build_tm_1_8_tc_5_X_RIDunknown(tm_descriptor, tm_seq_counter, evID, tc_descriptor);

    } else {

        if (get_event_action_config(evID, &mut index, &mut enabled, &(*event_action_config_table))){

            event_action_config_table[index].enabled = true;
            build_tm_1_7(tm_descriptor, tm_seq_counter, tc_descriptor);

        } else {

            build_tm_1_8_tc_19_X_event_action_not_defined(tm_descriptor, tm_seq_counter, evID, tc_descriptor);

        }
    }
    return;
}


function PUS_service_19_execTC (tc_descriptor : &TCDescriptorT, tm_descriptor : &mut TMDescriptorT, tm_seq_counter: u16,
                                event_action_config_table: &mut [EventActionConfig; max_event_action_definitions],
                                event_action_packs: &mut [TCDescriptorT; max_event_action_definitions]){

    var subtype : u8 = get_subtype(&(tc_descriptor->tc_bytes));
    
    if (subtype == 1){

        exec19_1TC(tc_descriptor, tm_descriptor, tm_seq_counter, event_action_config_table, event_action_packs);
    } 
    else if (subtype == 2){

        exec19_2TC(tc_descriptor, tm_descriptor, tm_seq_counter, event_action_config_table);

    } else if (subtype == 4){

        exec19_4TC(tc_descriptor, tm_descriptor, tm_seq_counter, event_action_config_table);
    
    } else if (subtype == 5){

        exec19_5TC(tc_descriptor, tm_descriptor, tm_seq_counter, event_action_config_table);

    } else {

        //This is an error in acceptance, could be modeled as an event
        /* If the acceptance process is correct, this point should not be reached */
    }

    return;
}