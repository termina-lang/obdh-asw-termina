import service_libraries.pus_services.pus_service3.pus_service3;
import service_libraries.pus_services.pus_service5.pus_service5;
import service_libraries.pus_services.pus_service12.pus_service12;
import service_libraries.pus_services.pus_service19.pus_service19;
import service_libraries.pus_services.pus_service4.pus_service4;
import service_libraries.errors;

const num_actions_per_second : usize = 2;

/**
* @brief Periodic monitoring and housekeeping task for handling FDIR (Fault Detection, Isolation and Recovery) and TC execution.
* 
* @details This task collects housekeeping data, performs monitoring using PUS service 12, manages triggered fault events,
* 
*/

task class HouseKeepingFDIR {

/// @brief Timer event to trigger periodic HK and FDIR actions.
    hk_fdir_timer_ev : sink TimeVal triggers do_hk_fdir;

    /// @brief Input queue for telecommands handled by the HK+FDIR system.
    hkfdir_message_queue_input: in box TCHandlerT triggers exec_tc;

    /// @brief Output queue for actions generated by FDIR to be executed.
    action_tc_message_queue_output: out box TCHandlerT;

    /// @brief Allocator for TCHandler objects.
    a_tc_handler_pool : access Allocator<TCHandlerT>;

    /// @brief Interface to PUS service 3 (Housekeeping service).
    pus_service_3 : access PUSS3Iface;

    /// @brief Interface to PUS service 12 (Monitoring service).
    pus_service_12 : access PUSS12Iface;

    /// @brief Interface to PUS service 5 (Event reporting service).
    pus_service_5 : access PUSS5Iface;

    /// @brief Interface to PUS service 19 (Action service).
    pus_service_19 : access PUSS19Iface;

    /// @brief Interface to PUS service 4 (Statistics service).
    pus_service_4 : access PUSS4Iface;

    /// @brief Interface to PUS service 9 (Timing service).
    pus_service_9 : access PUSS9Iface;

    /// @brief Interface to the Telemetry (TM) channel.
    tm_channel: access TMChannelIface;

    /// @brief Interface to the TM counter.
    tm_counter: access TMCounterIface;

    /// @brief Allocator for TMHandler objects.
    a_tm_handler_pool : access Allocator<TMHandlerT>;

    /**
     * @brief Performs FDIR monitoring for all enabled PMON IDs and handles triggered events.
     * @return Status code indicating the result of the operation.
    */ 
    method do_fdir(&priv self) -> Status<i32> {

        var result : Status<i32> = Success;

        var is_monitor_enabled : bool = false;

        for i : usize in 0 .. max_num_pmon_ids {

            self->pus_service_12.is_PMON_enabled(i, &mut is_monitor_enabled);

            if(is_monitor_enabled){

                var evID : u16 = 0;
                var fault_info : FaultInfo = FaultInfo::Empty;
                var event_triggered : bool = false;

                self->pus_service_12.do_monitoring(i as u16, &mut evID, &mut fault_info, &mut event_triggered);

                if(event_triggered){

                    var is_Ev_ID_enabled : bool = false;
                    self->pus_service_5.is_Ev_ID_enabled_ext(evID, &mut is_Ev_ID_enabled);

                    if(is_Ev_ID_enabled){

                        self->pus_service_5.build_and_tx_tm_5_x(&mut result, evID, fault_info);
                        self->pus_service_19.manage_event_action(evID);
                    } 

                }

            }
            
        }

        

        return result;
    }


    /**
    * @brief Executes housekeeping updates and fault monitoring, then extracts pending FDIR actions.
    * @param _current_time The current mission time value triggering the update.
    * @return Status code indicating the result of the operation.
    */
    action do_hk_fdir(&priv self, _current_time : TimeVal) -> Status<i32> {

        var result : Status<i32> = Success;

        self->pus_service_3.update_params();
        self->pus_service_4.update_all_stats(); 
        self->pus_service_3.do_hk(&mut result);
        result = self->do_fdir();

        var pending_actions : [usize; 4] = [0;4];
        self->pus_service_19.get_pending_action_number(&mut pending_actions);

        var n : usize = 4;

        if (pending_actions[3] > 0){

            n = 3;

        } else if (pending_actions[2] > 0){

            n = 2;

        } else if (pending_actions[1] > 0){

            n = 1;

        } else if (pending_actions[0] > 0){

            n = 0;

        } else {
            //Do nothing
        }

        if (n < 4){

            var tc_handler : Option<box TCHandlerT> = None;
            self->a_tc_handler_pool.alloc(&mut tc_handler);
            
            match tc_handler {

                case Some(b_tc_handler) => {

                    self->pus_service_19.extract_action(n, &mut b_tc_handler);
                    self->action_tc_message_queue_output.send(b_tc_handler);

                }
                case None => {
                    result = Failure(TM_POOL_ALLOC_FAILURE);
                
                }
            }
        }


        return result;
    }

    /**
     * @brief Builds and sends a TM[1,4] packet in case of an error during TC acceptance.
     * @param tc_handler The handler for the telecommand that failed.
     * @param ret Pointer to the status to be updated with the result. 
    */
    viewer manage_error_in_acceptance(&self, tc_handler: &TCHandlerT, status: &mut Status<i32>) {

        var current_obt : MissionObt = {seconds = 0, finetime = 0};

        var tm_handler : Option<box TMHandlerT> = None;
        self->a_tm_handler_pool.alloc(&mut tm_handler);

        match tm_handler {

            case Some(b_tm_handler) => {

                var tm_count : u16 = 0 : u16;
                self->tm_counter.get_next_tm_count(&mut tm_count);

                self->pus_service_9.get_current_obt(&mut current_obt);
                build_tm_1_4_error_in_acceptance(&mut b_tm_handler, tm_count, tc_handler->packet_header.packet_id, tc_handler->packet_error_ctrl,
                                 current_obt, status);
                
                if (*status is Success){

                    self->tm_channel.send_tm(b_tm_handler, status);
                } 
                else {
                    self->a_tm_handler_pool.free(b_tm_handler);
                        
                }
                
            }
            case None => {
                *status = Failure(TM_POOL_ALLOC_FAILURE);
                
            }
        }

        return;
    }

    /**
     * @brief Executes a telecommand received by the HK+FDIR system by delegating it to the appropriate PUS service.
     * @param tc_handler The TC handler box containing the telecommand.
     * @return Status code indicating the execution result.
    */
    action exec_tc(&priv self, tc_handler : box TCHandlerT)-> Status<i32> {

        var res : Status<i32> = Success;

        var tc_type : u8 = tc_handler.df_header.type;

        if (tc_type == 3){

            self->pus_service_3.exec_tc(&mut tc_handler, &mut res);

        } else if (tc_type == 5){

            self->pus_service_5.exec_tc(&mut tc_handler, &mut res);

        } else if (tc_type == 12){

            self->pus_service_12.exec_tc(&mut tc_handler, &mut res);

        } else if (tc_type == 19){

            self->pus_service_19.exec_tc(&mut tc_handler, &mut res);

        } 
        else if (tc_type == 4){

            self->pus_service_4.exec_tc(&mut tc_handler, &mut res);

        }else {

            self->manage_error_in_acceptance(&(tc_handler), &mut res);
        }
        

        self->a_tc_handler_pool.free(tc_handler);

        return res;
    }


};