import{modules.serialize, modules.ccsds_pus_format,resources.tm_channel,modules.epd_pus_tmtc, modules.crc}


task class TCEPDManager {

    a_tm_list_pool: access Allocator<TMDescriptorTList>;
    tc_descriptor_pool: access Allocator<TCDescriptorT>;
    hkfdir_message_queue_output: out dyn TCDescriptorT;
    bkg_message_queue_output: out dyn TCDescriptorT;
    tm_channel: access TMChannel;
    pus_service_1 : access PUSService1;

    tc_message_queue_input: in dyn TCDescriptorT triggers process_tc;



    action process_tc(&priv self, tc_descriptor: dyn TCDescriptorT) -> Result {

        var ret : Result = Result::Ok;

        self->pus_service_1.try_tc_acceptation(&tc_descriptor);

        match self->pus_service_1.acceptation_status {

            case TCAcceptationOK => {
                
                //generar tm(1,1)

                match self->pus_service_1.tc_execution_status {

                    case ExecCtrlReboot => {
                        //Ejecutar tc como prioritario
                    }
                    case  ExecCtrlHK_FDIRTC => {
                    
                        self->hk_message_queue_output.send(tc_descriptor);
                    }
                    case ExecCtrlBKGTC => {
                        //Enviar tc a tarea bkg
                    }
                    case ExecCtrlPrioTC => {
                        //Ejecutar tc como prioritario
                    }

                }
            }
            idk => {  //Esto no está implementado en el lenguaje, pero sería muy útil y eficiente
               
                //generar tm(1,2)

                //ojo, tengo en mente dos ideas diferentes para el tema de las listas de telemetrías
                // consultar con Pablo cuál es la mejor opción
            
            /*
                var tm_list : Option<TMDescriptorTList> = None;
                self->a_tm_list_pool.alloc(&mut tm_list);

                match tm_list {

                    case Some(list) => {

                        var tm_descriptor : TMDescriptorT;
                        var tm_count : u16 = 0 : u16;
                        self->tm_channel.get_next_tm_count(&mut tm_count);

                        self->pus_service_1.build_tm_1_2(&mut tm_descriptor, tm_count);

                    }
                    case None => {
                        //error
                    }
                }
            */

            }
        }
    
        return ret;            
    }

        
       


};