import service_libraries.pus_services.pus_service3;
import service_libraries.pus_services.pus_service12;
import service_libraries.pus_services.pus_service5;
import service_libraries.pus_services.pus_service19;
import service_libraries.event_list;
import service_libraries.tm_ccsds_pus_format;
import service_libraries.tc_ccsds_pus_format;
import service_libraries.serialize;
import handlers.init;
import resources.tm_counter;
import resources.system_data_pool;
import service_libraries.tm_list;

task class HK_FDIR_Manager {

    hk_fdir_timer_ev : sink TimeVal triggers do_hk_fdir;
    hkfdir_message_queue_input: in box TCDescriptorT triggers exec_tc;

    //HK_FDIR Structures
    hk_tm_list : TMList;

    
    
    event_list : EventList; //Maybe it is better to create an event list for each do_hkfdir execution
    
    pus_serv19_event_action_config : [EventActionConfig; max_event_action_definitions];
    pus_serv19_event_action_packets : [TCDescriptorT; max_event_action_definitions];
    //pus_serv19_priority_indexes : [usize; max_event_action_definitions];
    //In C we use an array. We need 4 queues, one for each type of event depending on the severity
    /*
    pus_serv19_pending_action_queue_1I : [TCDescriptorT; event_action_queue_dimension];
    pus_serv19_pending_action_queue_2LS : [TCDescriptorT; event_action_queue_dimension];
    pus_serv19_pending_action_queue_3MS : [TCDescriptorT; event_action_queue_dimension];
    pus_serv19_pending_action_queue_4HS : [TCDescriptorT; event_action_queue_dimension];
    
    
    pus_serv19_pending_action_number : [u8; 4];
    pus_serv19_pending_action_head : [u8; 4];
    */  
    //Do we really need queues?? It is not enough sending the action TC directly to the Manager task?

    a_tm_descriptor_pool : access Allocator<TMDescriptorT>;
    a_tc_descriptor_pool : access Allocator<TCDescriptorT>;
    system_data_pool : access AtomicArrayAccess<u16; SDP_num_params>; 
    tm_counter : access TMCounterIface;
    PUS_service_3 : access PUSS3Iface;
    PUS_service_12 : access PUSS12Iface;
    PUS_service_5 : access PUSS5Iface;

    tm_message_queue_output : out box TMDescriptorT;
    action_tc_message_queue_output : out box TCDescriptorT;

    


method pus_serv19_manage_event_actions(&priv self) -> Result {

    var res : Result = Result::Ok;

    for i : usize in 0 .. max_num_events while (i < self->event_list.num_events){
            
        var event_info : Option<EventInfo> = None;
        get_event_info(&(self->event_list), i, &mut event_info);
    
        match event_info {
    
            case Some(event) => {

                if(is_RID_enabled(event.ev_RID, &(self->pus_serv5_RID_enable_config))){

                    var index : usize = 0;
                    var enabled : bool = false;

                    if (get_event_action_config(event.ev_RID, &mut index, &mut enabled, &(self->pus_serv19_event_action_config))){

                        if(enabled){

                            //new pending event action
                            var tc_descriptor : Option<box TCDescriptorT> = None;
                            self->a_tc_descriptor_pool.alloc(&mut tc_descriptor);

                            match tc_descriptor {

                                case Some(descriptor) => {

                                    descriptor.tc_num_bytes = self->pus_serv19_event_action_packets[index].tc_num_bytes;

                                    for j : usize in 0 .. event_action_max_bytes while (j < descriptor.tc_num_bytes) {
                                        descriptor.tc_bytes[j] = self->pus_serv19_event_action_packets[index].tc_bytes[j];
                                    }

                                    
                                    self->action_tc_message_queue_output.send(descriptor);
                                }
                                case None => {
                                    res = Result::Error;
                                }
                            }


                        }
                    }
                }
            }
            case None => {
                //no events extracted
            }
        }
    }

    clear_ev_list(&mut (self->event_list));

    return res;
}
    

   




        

        
    
};