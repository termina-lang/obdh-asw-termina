import libraries.pus_services.pus_service3;
import libraries.pus_services.pus_service12;
import libraries.tm_ccsds_pus_format;
import libraries.tc_ccsds_pus_format;
import libraries.serialize;
import handlers.init;
import resources.tm_counter;

task class HK_FDIR_MNG {

    hk_fdir_timer_ev : sink TimeVal triggers do_hk_fdir;
    hkfdir_message_queue_input: in dyn TCDescriptorT triggers exec_tc;

    hk_config_table : [HKConfiguration; max_num_of_SIDs];
    param_mon_config_table : [ParamMonitoringConfiguration; max_num_pmon_ids];
    param_limit_check_definition : [ParamLimitCheckDefinition; max_num_pmon_ids];
    a_tm_descriptor_pool : access Allocator<TMDescriptorT>;
    system_data_pool : access AtomicArrayAccess<u16; SDP_num_params>;
    tm_message_queue_output : out TMDescriptorT; 
    tm_counter : access TMCounterIface;

    viewer pus_serv3_build_tm_3_25(&self, p_tm_descriptor : &mut TMDescriptorT, tm_seq_counter : u16, index: usize) -> Result {

        var res : Result = Result::Ok;


        var tm_packet_header : CCSDSPUSTMPacketHeaderT =
	                                     {packet_id = 0 : u16,
	                                      packet_seq_ctrl = 0 : u16,
	                                      packet_length = 0 : u16};
	    var df_header : CCSDSPUSTMDFHeaderT =
										{version = 0 : u8,
	 									type = 0 : u8,
	 									subtype = 0 : u8,
	 									destinationID = 0 : u8};

	    tm_packet_header.packet_id = ccsds_pus_tm_build_packet_id(0x32C : u16);

	    tm_packet_header.packet_seq_ctrl = ccsds_pus_tm_build_packet_seq_ctrl(0x3 : u16, tm_seq_counter);

	    tm_packet_header.packet_length = 7 + 1 + 2*(self->hk_config_table[index].num_params as u16); //Packet length dependent on SID

	    df_header.version = ccsds_pus_tm_build_df_header_version(0x1 : u8);
	    df_header.type = 3 : u8;
	    df_header.subtype = 25 : u8;
	    df_header.destinationID = 0x78 : u8;

	    ccsds_pus_tm_set_fields(&mut p_tm_descriptor->tm_bytes[0 : usize .. 10 : usize], &tm_packet_header, &df_header);

	    p_tm_descriptor->tm_bytes[10 : usize] = self->hk_config_table[index].SID;

        var PID : usize = 0;
        var SDP_value : u16 = 0;

        for j : usize in 0 .. max_params_per_SID while (j < (self->hk_config_table[index].num_params as usize)) {

            PID = self->hk_config_table[index].params_def[j] as usize;
            self->system_data_pool.load_index(PID, &mut SDP_value);
            serialize_uint16(SDP_value, &mut (p_tm_descriptor->tm_bytes[11 + j..13 + j]));
    
        }

	    // Calculate p_tm_descriptor->tm_num_bytes
	    p_tm_descriptor->tm_num_bytes = 6 : u16 + tm_packet_header.packet_length + 1 : u16;


	    return res;
    }
    

    method do_hk (&mut self) -> Result {

        var res : Result = Result::Ok;

        for i : usize in 0 .. max_num_of_SIDs {

            if (self->hk_config_table[i].enabled == true){

                self->hk_config_table[i].interval_control = self->hk_config_table[i].interval_control + 1;

                if (self->hk_config_table[i].interval_control == self->hk_config_table[i].interval){

                    self->hk_config_table[i].interval_control = 0;

                    var tm_descriptor : Option<dyn TMDescriptorT> = None;
                    self->a_tm_descriptor_pool.alloc(&mut tm_descriptor);

                    match tm_descriptor {

                        case Some(descriptor) => {

                        var tm_count : u16 = 0 : u16;
                        self->tm_counter.get_next_tm_count(&mut tm_count);

                        res = pus_serv3_build_tm_3_25(&mut descriptor, tm_count, i);
                        self.tm_message_queue_output.send(descriptor);
                   
                        }
                        case None => {
                            res = Result::Error;
                        }
                    }       
                }
            }
        }

        return res;
    }

/*
    method do_monitoring (&mut self) -> Result {

        
    }
    */





    action do_hk_fdir(&mut self, _current_time : TimeVal) -> Result {

        var res : Result = Result::Ok;

        self->do_hk();

        return res;
    } 


    action exec_tc(&mut self, tc_descriptor : dyn TCDescriptorT) -> Result {

        var res : Result = Result::Ok;

        var tm_descriptor : Option<dyn TMDescriptorT> = None;
        self->a_tm_descriptor_pool.alloc(&mut tm_descriptor);

        match tm_descriptor {

            case Some(descriptor) => {

                var tm_count : u16 = 0 : u16;
                self->tm_counter.get_next_tm_count(&mut tm_count);
    
                PUS_hk_fdir_exec_tc(&tc_descriptor,&mut descriptor, tm_count, &(self->hk_config_table));
                self.tm_message_queue_output.send(descriptor);
                        
            }
            case None => {
                //error
                res = Result::Error;
            }
        }

        return res;
    }

        
    
};