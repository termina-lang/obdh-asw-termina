import libraries.pus_services.pus_service3;
import libraries.pus_services.pus_service12;
import libraries.pus_services.pus_service5;
import libraries.pus_services.pus_service19;
import libraries.event_list;
import libraries.tm_ccsds_pus_format;
import libraries.tc_ccsds_pus_format;
import libraries.serialize;
import handlers.init;
import resources.tm_counter;
import resources.system_data_pool;

task class HK_FDIR_Manager {

    hk_fdir_timer_ev : sink TimeVal triggers do_hk_fdir;
    hkfdir_message_queue_input: in dyn TCDescriptorT triggers exec_tc;

    //HK_FDIR Structures

    pus_serv3_hk_config_table : [HKConfiguration; max_num_of_SIDs];
    pus_serv12_param_mon_config_table : [ParamMonitoringConfiguration; max_num_pmon_ids];
    pus_serv12_param_limit_check_definition : [ParamLimitCheckDefinition; max_num_pmon_ids];
    event_list : EventList;
    pus_serv5_RID_enable_config : [u32; 4];
    pus_serv19_event_action_config : [EventActionConfig; max_event_action_definitions];
    pus_serv19_event_action_packets : [TCDescriptorT; max_event_action_definitions];
    //pus_serv19_priority_indexes : [usize; max_event_action_definitions];
    //In C we use an array. We need 4 queues, one for each type of event depending on the severity
    /*
    pus_serv19_pending_action_queue_1I : [TCDescriptorT; event_action_queue_dimension];
    pus_serv19_pending_action_queue_2LS : [TCDescriptorT; event_action_queue_dimension];
    pus_serv19_pending_action_queue_3MS : [TCDescriptorT; event_action_queue_dimension];
    pus_serv19_pending_action_queue_4HS : [TCDescriptorT; event_action_queue_dimension];
    
    
    pus_serv19_pending_action_number : [u8; 4];
    pus_serv19_pending_action_head : [u8; 4];
    */  
    //Do we really need queues?? It is not enough sending the action TC directly to the Manager task?

    a_tm_descriptor_pool : access Allocator<TMDescriptorT>;
    a_tc_descriptor_pool : access Allocator<TCDescriptorT>;
    system_data_pool : access AtomicArrayAccess<u16; SDP_num_params>; 
    tm_counter : access TMCounterIface;

    tm_message_queue_output : out dyn TMDescriptorT;
    action_tc_message_queue_output : out dyn TCDescriptorT;

    viewer pus_serv3_build_tm_3_25(&self, p_tm_descriptor : &mut TMDescriptorT, tm_seq_counter : u16, index: usize) {

        var tm_packet_header : CCSDSPUSTMPacketHeaderT =
	                                     {packet_id = 0 : u16,
	                                      packet_seq_ctrl = 0 : u16,
	                                      packet_length = 0 : u16};
	    var df_header : CCSDSPUSTMDFHeaderT =
										{version = 0 : u8,
	 									type = 0 : u8,
	 									subtype = 0 : u8,
	 									destinationID = 0 : u8};

	    tm_packet_header.packet_id = ccsds_pus_tm_build_packet_id(0x32C : u16);

	    tm_packet_header.packet_seq_ctrl = ccsds_pus_tm_build_packet_seq_ctrl(0x3 : u16, tm_seq_counter);

        //Check this calculation, I'm not sure it's correct
	    tm_packet_header.packet_length = 4 + 2*(self->pus_serv3_hk_config_table[index].num_params as u16); //Packet length dependent on SID

	    df_header.version = ccsds_pus_tm_build_df_header_version(0x1 : u8);
	    df_header.type = 3 : u8;
	    df_header.subtype = 25 : u8;
	    df_header.destinationID = 0x78 : u8;

	    ccsds_pus_tm_set_fields(&mut p_tm_descriptor->tm_bytes[0 : usize .. 10 : usize], &tm_packet_header, &df_header);

	    p_tm_descriptor->tm_bytes[10 : usize] = self->pus_serv3_hk_config_table[index].SID;

        var PID : usize = 0;
        var SDP_value : u16 = 0;

        for j : usize in 0 .. max_params_per_SID while (j < (self->pus_serv3_hk_config_table[index].num_params as usize)) {

            PID = self->pus_serv3_hk_config_table[index].params_def[j] as usize;
            self->system_data_pool.load_index(PID, &mut SDP_value);
            serialize_uint16(SDP_value, &mut (p_tm_descriptor->tm_bytes[11 + j..13 + j]));
    
        }

	    // Calculate p_tm_descriptor->tm_num_bytes
	    p_tm_descriptor->tm_num_bytes = 6 : u16 + tm_packet_header.packet_length + 1 : u16;


	    return;
    }
    

    method pus_serv3_do_hk (&mut self) -> Result {

        var res : Result = Result::Ok;

        for i : usize in 0 .. max_num_of_SIDs {

            if (self->pus_serv3_hk_config_table[i].enabled == true){

                self->pus_serv3_hk_config_table[i].interval_control = self->pus_serv3_hk_config_table[i].interval_control + 1;

                if (self->pus_serv3_hk_config_table[i].interval_control == self->pus_serv3_hk_config_table[i].interval){

                    self->pus_serv3_hk_config_table[i].interval_control = 0;

                    var tm_descriptor : Option<dyn TMDescriptorT> = None;
                    self->a_tm_descriptor_pool.alloc(&mut tm_descriptor);

                    match tm_descriptor {

                        case Some(descriptor) => {

                        var tm_count : u16 = 0 : u16;
                        self->tm_counter.get_next_tm_count(&mut tm_count);

                        self->pus_serv3_build_tm_3_25(&mut descriptor, tm_count, i);
                        self->tm_message_queue_output.send(descriptor);
                   
                        }
                        case None => {
                            res = Result::Error;
                        }
                    }       
                }
            }
        }

        return res;
    }

    method pus_serv12_do_monitoring (&mut self) -> Result {

        var res : Result = Result::Ok;

        for i : usize in 0 .. max_num_pmon_ids {

            if(self->pus_serv12_param_mon_config_table[i].enabled == true){

                var PID : u16 = self->pus_serv12_param_mon_config_table[i].PID;
                var SDP_value : u16 = 0;
                self->system_data_pool.load_index(PID as usize, &mut SDP_value);

                if(self->pus_serv12_param_mon_config_table[i].interval_control >= self->pus_serv12_param_mon_config_table[i].interval){

                    self->pus_serv12_param_mon_config_table[i].interval_control = 0;

                    if(self->pus_serv12_param_mon_config_table[i].state is CheckState::MonitorUnselected == false){

                        if (self->pus_serv12_param_mon_config_table[i].state is CheckState::MonitorAboveHighLimit == false) &&
                            (self->pus_serv12_param_mon_config_table[i].state is CheckState::MonitorBelowLowLimit== false) {

                            if (SDP_value > self->pus_serv12_param_limit_check_definition[i].high_limit){

                                trigger_event(&mut (self->event_list), self->pus_serv12_param_limit_check_definition[i].high_limit_rid, PID, SDP_value,
                                        self->pus_serv12_param_limit_check_definition[i].high_limit, &mut res);
                                var updated_state : CheckState = CheckState::MonitorAboveHighLimit;
                                update_state(&mut (self->pus_serv12_param_mon_config_table), i, updated_state);
                            
                            } else if (SDP_value < self->pus_serv12_param_limit_check_definition[i].low_limit){

                                trigger_event(&mut (self->event_list), self->pus_serv12_param_limit_check_definition[i].low_limit_rid, PID, SDP_value,
                                        self->pus_serv12_param_limit_check_definition[i].low_limit, &mut res);
                                var updated_state : CheckState = CheckState::MonitorBelowLowLimit;
                                update_state(&mut (self->pus_serv12_param_mon_config_table), i, updated_state);

                            } else {

                                if (self->pus_serv12_param_mon_config_table[i].state is CheckState::MonitorUnchecked){

                                    var updated_state : CheckState = CheckState::MonitorWithinLimits;
                                    update_state(&mut (self->pus_serv12_param_mon_config_table), i, updated_state);

                                }
                            }
                        } else {

                        if (SDP_value < self->pus_serv12_param_limit_check_definition[i].high_limit) &&
                            (SDP_value > self->pus_serv12_param_limit_check_definition[i].low_limit){

                                var updated_state : CheckState = CheckState::MonitorWithinLimits;
                                update_state(&mut (self->pus_serv12_param_mon_config_table), i, updated_state);
                            }
                        }
                    } else {

                        self->pus_serv12_param_mon_config_table[i].interval_control = self->pus_serv12_param_mon_config_table[i].interval_control + 1;
                    }
                }

            }

        }

        return res;   
    }


    method pus_serv5_build_event_list_tms(&mut self) -> Result {

        var res : Result = Result::Ok;

        for i : usize in 0 .. max_num_events while (i < self->event_list.num_events) {

            var event_info : Option<EventInfo> = None;

            get_event_info(&(self->event_list), i, &mut event_info);

            match event_info {
                
                case Some(event) => {

                    if(is_RID_enabled(event.ev_RID, &(self->pus_serv5_RID_enable_config))){

                        var index : usize = get_RID_enable_config_index(event.ev_RID);

                        if (index < 4){

                            var tm_descriptor : Option<dyn TMDescriptorT> = None;
                            self->a_tm_descriptor_pool.alloc(&mut tm_descriptor);

                            match tm_descriptor {

                                case Some(descriptor) => {

                                    var tm_count : u16 = 0 : u16;
                                    self->tm_counter.get_next_tm_count(&mut tm_count);

                                    build_tm_5_x(&mut descriptor, tm_count, &event, index);
                                    self->tm_message_queue_output.send(descriptor);
                                }
                                case None => {
                                    res = Result::Error;
                                }
                            }

                        }
                    }
                }
                case None => {
                    //no events extracted
                }
            }

        }

      return res; 

    }


method pus_serv19_manage_event_actions(&mut self) -> Result {

    var res : Result = Result::Ok;

    for i : usize in 0 .. max_num_events while (i < self->event_list.num_events){
            
        var event_info : Option<EventInfo> = None;
        get_event_info(&(self->event_list), i, &mut event_info);
    
        match event_info {
    
            case Some(event) => {

                if(is_RID_enabled(event.ev_RID, &(self->pus_serv5_RID_enable_config))){

                    var index : usize = 0;
                    var enabled : bool = false;

                    if (get_event_action_config(event.ev_RID, &mut index, &mut enabled, &(self->pus_serv19_event_action_config))){

                        if(enabled){

                            //new pending event action
                            var tc_descriptor : Option<dyn TCDescriptorT> = None;
                            self->a_tc_descriptor_pool.alloc(&mut tc_descriptor);

                            match tc_descriptor {

                                case Some(descriptor) => {

                                    descriptor.tc_num_bytes = self->pus_serv19_event_action_packets[index].tc_num_bytes;

                                    for j : usize in 0 .. event_action_max_bytes while (j < descriptor.tc_num_bytes) {
                                        descriptor.tc_bytes[j] = self->pus_serv19_event_action_packets[index].tc_bytes[j];
                                    }

                                    
                                    self->action_tc_message_queue_output.send(descriptor);
                                }
                                case None => {
                                    res = Result::Error;
                                }
                            }


                        }
                    }
                }
            }
            case None => {
                //no events extracted
            }
        }
    }

    clear_ev_list(&mut (self->event_list));

    return res;
}
    

    action do_hk_fdir(&mut self, _current_time : TimeVal) -> Result {

        var res : Result = Result::Ok;

        res = self->pus_serv3_do_hk();
        res = self->pus_serv12_do_monitoring();
        res = self->pus_serv5_build_event_list_tms();

        return res;
    } 


    action PUS_hk_fdir_exec_tc(&mut self, tc_descriptor : dyn TCDescriptorT) -> Result {

        var res : Result = Result::Ok;

        var tm_descriptor : Option<dyn TMDescriptorT> = None;
        self->a_tm_descriptor_pool.alloc(&mut tm_descriptor);

        match tm_descriptor {

            case Some(descriptor) => {

                var tm_count : u16 = 0 : u16;
                self->tm_counter.get_next_tm_count(&mut tm_count);
    
                var tc_type : u8 = get_type(&(tc_descriptor.tc_bytes));

                if (tc_type == 3){

                    PUS_service_3_execTC(&tc_descriptor, &mut descriptor, tm_count, &mut (self->pus_serv3_hk_config_table));
    
                } else if (tc_type == 5){

                    PUS_service_5_execTC(&tc_descriptor, &mut descriptor, tm_count,  &mut (self->pus_serv5_RID_enable_config));

                } else if (tc_type == 12){

                    PUS_service_12_execTC(&tc_descriptor, &mut descriptor, tm_count,  &mut (self->pus_serv12_param_mon_config_table),  &mut(self->pus_serv12_param_limit_check_definition));

                } else if (tc_type == 19){

                    PUS_service_19_execTC(&tc_descriptor, &mut descriptor, tm_count,  &mut (self->pus_serv19_event_action_config),  &mut (self->pus_serv19_event_action_packets));

                } else {

                    //This is an error in acceptance, could be modeled as an event
                }

                self->tm_message_queue_output.send(descriptor);
                        
            }
            case None => {
                //error
                res = Result::Error;
            }

        }

        self->a_tc_descriptor_pool.free(tc_descriptor);

        return res;
    }

        
    
};