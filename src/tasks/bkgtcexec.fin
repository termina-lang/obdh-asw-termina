import service_libraries.pus_services.pus_service1.pus_service1;
import service_libraries.pus_services.pus_service20;
import service_libraries.serialize;
import resources.system_data_pool;
import service_libraries.tc_ccsds_pus_format;
import service_libraries.tm_ccsds_pus_format;
import resources.tm_counter;

task class PUSBKGTCExecutor {

    bkg_message_queue_input: in box TCDescriptorT triggers exec_tc;

    a_tm_descriptor_pool : access Allocator<TMDescriptorT>;
    a_tc_descriptor_pool : access Allocator<TCDescriptorT>;
    tm_channel: access TMChannelIface;
    tm_counter : access TMCounterIface;
    pus_service_20 : access PUSS20Iface;
  

    action exec_tc(&priv self, tc_descriptor : box TCDescriptorT)-> Result {

        var res : Result = Result::Ok;

        var tm_descriptor : Option<box TMDescriptorT> = None;
        self->a_tm_descriptor_pool.alloc(&mut tm_descriptor);

        match tm_descriptor {

            case Some(descriptor) => {

                var tm_count : u16 = 0 : u16;
                self->tm_counter.get_next_tm_count(&mut tm_count);
    
                var tc_type : u8 = get_type(&(tc_descriptor.tc_bytes));
                var subtype : u8 = get_subtype(&(tc_descriptor.tc_bytes));

                if (tc_type == 20){

                    if (subtype == 1){

                        self->pus_service_20.exec20_1TC(&tc_descriptor, &mut descriptor, tm_count, &mut res);
                    } 
                    else if (subtype == 3){

                        self->pus_service_20.exec20_3TC(&tc_descriptor, &mut descriptor, tm_count);

                    } else {

                        //This is an error in acceptance, could be modeled as an event
                        /* If the acceptance process is correct, this point should not be reached */
                    }

                } else {

                    //This is an error in acceptance, could be modeled as an event
                }

                self->tm_channel.send_tm(descriptor, &mut res); //This will have to be changed. TM_CHANNEL will be a resource
                        
            }
            case None => {
                //error
                res = Result::Error;
            }

        }

        self->a_tc_descriptor_pool.free(tc_descriptor);

        return res;
    }


        


};