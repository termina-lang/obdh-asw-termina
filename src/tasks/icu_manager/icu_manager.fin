import service_libraries.tc_ccsds_pus_format;
import service_libraries.tm_ccsds_pus_format;
import service_libraries.pus_services.pus_service1.pus_service1;
import service_libraries.pus_services.pus_service2;
import service_libraries.pus_services.pus_service9;
import service_libraries.pus_services.pus_service17;
import service_libraries.pus_services.pus_service128;
import resources.tm_counter;

task class ICUManager {

    tc_message_queue_input: in box TCDescriptorT triggers process_tc;
    action_tc_message_queue_input: in box TCDescriptorT triggers process_action_tc;
    a_tc_descriptor_pool : access Allocator<TCDescriptorT>;
    a_tm_descriptor_pool : access Allocator<TMDescriptorT>;
    hkfdir_message_queue_output: out box TCDescriptorT;
    bkg_message_queue_output: out box TCDescriptorT;
    tm_channel: access TMChannelIface;
    tm_counter: access TMCounterIface;

    current_tc : TCDescriptorT;
    current_tc_status : TCStatus;

    method PUS_prio_exec_tc (&priv self) -> Result {

        var ret : Result = Result::Ok;

        var tm_descriptor : Option<box TMDescriptorT> = None;
        self->a_tm_descriptor_pool.alloc(&mut tm_descriptor);
        
        match tm_descriptor {

            case Some(descriptor) => {

                var tm_count : u16 = 0 : u16;
                self->tm_counter.get_next_tm_count(&mut tm_count);

                var tc_type : u8 = get_type(&(self->current_tc.tc_bytes));

                if (tc_type == 17){

                    PUS_service_17_execTC(&(self->current_tc), &mut descriptor, tm_count);
            
                } /*else if (tc_type == 2){

                    PUS_service_2_execTC(&(self->current_tc), &mut descriptor, tm_count);
            
                } else if (tc_type == 9){

                    PUS_service_9_execTC(&(self->current_tc), &mut descriptor, tm_count);
            
                } else if (tc_type == 128){

                    PUS_service_128_execTC(&(self->current_tc), &mut descriptor, tm_count); 
                
                }*/ else {

                    ret = Result::Error;
                }

                self->tm_channel.send_tm(descriptor, &mut ret);
        
            }
            case None => {
                ret = Result::Error;
            }
        }
        
        return ret;
    }

    method mng_tc_acceptation (&priv self) -> Result {

        var tm_descriptor : Option<box TMDescriptorT> = None;
        self->a_tm_descriptor_pool.alloc(&mut tm_descriptor);

        var ret : Result = Result::Ok;

        match tm_descriptor {

            case Some(descriptor) => {

                var tm_count : u16 = 0 : u16;
                self->tm_counter.get_next_tm_count(&mut tm_count);
                //generar TM(1,1)
                build_tm_1_1(&mut descriptor, tm_count, &(self->current_tc));
                self->tm_channel.send_tm(descriptor, &mut ret);
                        
            }
            case None => {
                ret = Result::Error;
            }
        }

        return ret;
    }


    method mng_tc_rejection (&priv self) -> Result {

        var tm_descriptor : Option<box TMDescriptorT> = None;
        self->a_tm_descriptor_pool.alloc(&mut tm_descriptor);

        var ret : Result = Result::Ok;

            match tm_descriptor {

                case Some(descriptor) => {

                    var tm_count : u16 = 0 : u16;
                    self->tm_counter.get_next_tm_count(&mut tm_count);
                    //generar TM(1,2)
                    build_tm_1_2(&(self->current_tc_status), &mut descriptor, tm_count, &(self->current_tc));
                    self->tm_channel.send_tm(descriptor, &mut ret);
                
                }
                case None => {
                    ret = Result::Error;
                }
            }
        return ret;
    }



    action process_tc(&priv self, tc_descriptor: box TCDescriptorT) -> Result {

        var ret : Result = Result::Ok;

        self->current_tc = tc_descriptor;
        self->current_tc_status = try_tc_acceptation(&tc_descriptor);

        match self->current_tc_status.acceptation_status {

            case Accepted => {

                ret = self->mng_tc_acceptation();


                match self->current_tc_status.execution_status {

                    case ExecCtrlReboot => {

                        //Ejecutar tc como prioritario
                        ret = self->PUS_prio_exec_tc();
                        self->a_tc_descriptor_pool.free(tc_descriptor);
                           
                    }
                    case  ExecCtrlHK_FDIRTC => {
                    
                        self->hkfdir_message_queue_output.send(tc_descriptor);
                    }
                    case ExecCtrlBKGTC => {
                        
                        self->bkg_message_queue_output.send(tc_descriptor);
                    }
                    case ExecCtrlPrioTC => {

                        //Ejecutar tc como prioritario
                        ret = self->PUS_prio_exec_tc();
                        self->a_tc_descriptor_pool.free(tc_descriptor);
                    }
                    case Undefined => {
                        ret = Result::Error;
                        self->a_tc_descriptor_pool.free(tc_descriptor);
                    }

                }    
            }
            case Rejected => { 

                ret = self->mng_tc_rejection();
                self->a_tc_descriptor_pool.free(tc_descriptor);
            }
            case Undefined => {
                ret = Result::Error;
                self->a_tc_descriptor_pool.free(tc_descriptor);
            }
        }
        return ret;            
    }


    action process_action_tc(&priv self, tc_descriptor: box TCDescriptorT) -> Result {

        var ret : Result = Result::Ok;

        self->current_tc = tc_descriptor;
        var execution_status : TCExecutionCtrl = handle_tc(&tc_descriptor);

        match execution_status {

            case ExecCtrlReboot => {

                //Ejecutar tc como prioritario
                ret = self->PUS_prio_exec_tc();
                self->a_tc_descriptor_pool.free(tc_descriptor); 
            }
            case  ExecCtrlHK_FDIRTC => {
            
                self->hkfdir_message_queue_output.send(tc_descriptor);
            }
            case ExecCtrlBKGTC => {
                
                self->bkg_message_queue_output.send(tc_descriptor);
            }
            case ExecCtrlPrioTC => {

            //Ejecutar tc como prioritario
                ret = self->PUS_prio_exec_tc();
                self->a_tc_descriptor_pool.free(tc_descriptor); 
            }
            case Undefined => {
                ret = Result::Error;
                self->a_tc_descriptor_pool.free(tc_descriptor);
            }

        }
        
        return ret;            
    }


};