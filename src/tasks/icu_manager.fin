import libraries.serialize;
import libraries.ccsds_pus_format;
import resources.tm_channel;
import libraries.epd_pus_tmtc;
import libraries.crc;
import libraries.pus_services.pus_service17;


task class ICUManager {

    tc_message_queue_input: in dyn TCDescriptorT triggers process_tc;
    a_tc_descriptor_pool : access Allocator<TCDescriptorT>;
    a_tm_descriptor_pool : access Allocator<TMDescriptorT>;
    hkfdir_message_queue_output: out dyn TCDescriptorT;
    bkg_message_queue_output: out dyn TCDescriptorT;
    tm_message_queue_output : out TMDescriptorT; 
    tm_counter: access TMCounterIface;

    tc_status : TCStatus;

    viewer PUS_prio_exec_tc (&self, tc_descriptor : & TCDescriptorT, tm_descriptor : &mut TMDescriptorT, tm_seq_counter : u16){

        var tc_type : u8 = get_type(&(tc_descriptor->tc_bytes));

        if (tc_type == 17){

            PUS_service_17_execTC(tc_descriptor, tm_descriptor, tm_seq_counter);
    
        } 
    
        return;
    }


    action process_tc(&mut self, tc_descriptor: dyn TCDescriptorT) -> Result {

        var ret : Result = Result::Ok;

        try_tc_acceptation(&tc_descriptor, &mut (self->tc_status));

        match self->tc_status.acceptation_status {

            case Accepted => {

                var tm_descriptor : Option<dyn TMDescriptorT> = None;
                self->a_tm_descriptor_pool.alloc(&mut tm_descriptor);

                    match tm_descriptor {

                        case Some(descriptor) => {

                            var tm_count : u16 = 0 : u16;
                            self->tm_counter.get_next_tm_count(&mut tm_count);
                            //generar TM(1,1)
                            build_tm_1_1(&tc_descriptor,&mut descriptor, tm_count);
                            self.tm_message_queue_output.send(descriptor);
                        
                            }
                            case None => {
                                //error
                            }
                        }

                match self->tc_status.tc_execution_status {

                    case ExecCtrlReboot => {

                        
                        
                    }
                    case  ExecCtrlHK_FDIRTC => {
                    
                        self->hk_message_queue_output.send(tc_descriptor);
                    }
                    case ExecCtrlBKGTC => {
                        //Enviar tc a tarea bkg
                    }
                    case ExecCtrlPrioTC => {

                        var tm_descriptor : Option<dyn TMDescriptorT> = None;
                        self->a_tm_descriptor_pool.alloc(&mut tm_descriptor);

                        match tm_descriptor {

                            case Some(descriptor) => {

                                var tm_count : u16 = 0 : u16;
                                self->tm_counter.get_next_tm_count(&mut tm_count);
                                //Ejecutar tc como prioritario
                                PUS_prio_exec_tc(&tc_descriptor,&mut descriptor, tm_count);
                                self.tm_message_queue_output.send(descriptor);
                        
                            }
                            case None => {
                                //error
                            }
                        }
                    }

                }
            }
            case Rejected => { 

                var tm_descriptor : Option<dyn TMDescriptorT> = None;
                self->a_tm_descriptor_pool.alloc(&mut tm_descriptor);

                    match tm_descriptor {

                        case Some(descriptor) => {

                            var tm_count : u16 = 0 : u16;
                            self->tm_counter.get_next_tm_count(&mut tm_count);
                            //generar TM(1,2)
                            build_tm_1_2(&tc_status, &mut descriptor, tm_count, &tc_descriptor);
                            self.tm_message_queue_output.send(descriptor);
                        
                            }
                            case None => {
                                //error
                            }
                        }
            }
        }
    
        return ret;            
    }

        
       


};